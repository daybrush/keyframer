{"version":3,"file":"keyframer.pkgd.min.js","sources":["../node_modules/@daybrush/utils/dist/utils.esm.js","../node_modules/scenejs/dist/scene.esm.js","../src/consts.ts","../src/Keyframer.ts"],"sourcesContent":["/*\nCopyright (c) 2018 Daybrush\n@name: @daybrush/utils\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/utils\n@version 0.7.1\n*/\n/**\n* @namespace\n* @name Consts\n*/\n\n/**\n* get string \"rgb\"\n* @memberof Color\n* @example\nimport {RGB} from \"@daybrush/utils\";\n\nconsole.log(RGB); // \"rgb\"\n*/\nvar RGB = \"rgb\";\n/**\n* get string \"rgba\"\n* @memberof Color\n* @example\nimport {RGBA} from \"@daybrush/utils\";\n\nconsole.log(RGBA); // \"rgba\"\n*/\n\nvar RGBA = \"rgba\";\n/**\n* get string \"hsl\"\n* @memberof Color\n* @example\nimport {HSL} from \"@daybrush/utils\";\n\nconsole.log(HSL); // \"hsl\"\n*/\n\nvar HSL = \"hsl\";\n/**\n* get string \"hsla\"\n* @memberof Color\n* @example\nimport {HSLA} from \"@daybrush/utils\";\n\nconsole.log(HSLA); // \"hsla\"\n*/\n\nvar HSLA = \"hsla\";\n/**\n* gets an array of color models.\n* @memberof Color\n* @example\nimport {COLOR_MODELS} from \"@daybrush/utils\";\n\nconsole.log(COLOR_MODELS); // [\"rgb\", \"rgba\", \"hsl\", \"hsla\"];\n*/\n\nvar COLOR_MODELS = [RGB, RGBA, HSL, HSLA];\n/**\n* get string \"function\"\n* @memberof Consts\n* @example\nimport {FUNCTION} from \"@daybrush/utils\";\n\nconsole.log(FUNCTION); // \"function\"\n*/\n\nvar FUNCTION = \"function\";\n/**\n* get string \"property\"\n* @memberof Consts\n* @example\nimport {PROPERTY} from \"@daybrush/utils\";\n\nconsole.log(PROPERTY); // \"property\"\n*/\n\nvar PROPERTY = \"property\";\n/**\n* get string \"array\"\n* @memberof Consts\n* @example\nimport {ARRAY} from \"@daybrush/utils\";\n\nconsole.log(ARRAY); // \"array\"\n*/\n\nvar ARRAY = \"array\";\n/**\n* get string \"object\"\n* @memberof Consts\n* @example\nimport {OBJECT} from \"@daybrush/utils\";\n\nconsole.log(OBJECT); // \"object\"\n*/\n\nvar OBJECT = \"object\";\n/**\n* get string \"string\"\n* @memberof Consts\n* @example\nimport {STRING} from \"@daybrush/utils\";\n\nconsole.log(STRING); // \"string\"\n*/\n\nvar STRING = \"string\";\n/**\n* get string \"number\"\n* @memberof Consts\n* @example\nimport {NUMBER} from \"@daybrush/utils\";\n\nconsole.log(NUMBER); // \"number\"\n*/\n\nvar NUMBER = \"number\";\n/**\n* get string \"undefined\"\n* @memberof Consts\n* @example\nimport {UNDEFINED} from \"@daybrush/utils\";\n\nconsole.log(UNDEFINED); // \"undefined\"\n*/\n\nvar UNDEFINED = \"undefined\";\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @example\nimport {IS_WINDOW} from \"@daybrush/utils\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\n\nvar IS_WINDOW = typeof window !== UNDEFINED;\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @name document\n* @example\nimport {IS_WINDOW} from \"@daybrush/utils\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\n\nvar doc = typeof document !== UNDEFINED && document;\nvar prefixes = [\"webkit\", \"ms\", \"moz\", \"o\"];\n/**\n * @namespace CrossBrowser\n */\n\n/**\n* Get a CSS property with a vendor prefix that supports cross browser.\n* @function\n* @param {string} property - A CSS property\n* @return {string} CSS property with cross-browser vendor prefix\n* @memberof CrossBrowser\n* @example\nimport {getCrossBrowserProperty} from \"@daybrush/utils\";\n\nconsole.log(getCrossBrowserProperty(\"transform\")); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\nconsole.log(getCrossBrowserProperty(\"filter\")); // \"filter\", \"-webkit-filter\"\n*/\n\nvar getCrossBrowserProperty =\n/*#__PURE__*/\nfunction (property) {\n  if (!doc) {\n    return \"\";\n  }\n\n  var styles = (doc.body || doc.documentElement).style;\n  var length = prefixes.length;\n\n  if (typeof styles[property] !== UNDEFINED) {\n    return property;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    var name = \"-\" + prefixes[i] + \"-\" + property;\n\n    if (typeof styles[name] !== UNDEFINED) {\n      return name;\n    }\n  }\n\n  return \"\";\n};\n/**\n* get string \"transfrom\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {TRANSFORM} from \"@daybrush/utils\";\n\nconsole.log(TRANSFORM); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\n*/\n\nvar TRANSFORM =\n/*#__PURE__*/\ngetCrossBrowserProperty(\"transform\");\n/**\n* get string \"filter\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {FILTER} from \"@daybrush/utils\";\n\nconsole.log(FILTER); // \"filter\", \"-ms-filter\", \"-webkit-filter\"\n*/\n\nvar FILTER =\n/*#__PURE__*/\ngetCrossBrowserProperty(\"filter\");\n/**\n* get string \"animation\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {ANIMATION} from \"@daybrush/utils\";\n\nconsole.log(ANIMATION); // \"animation\", \"-ms-animation\", \"-webkit-animation\"\n*/\n\nvar ANIMATION =\n/*#__PURE__*/\ngetCrossBrowserProperty(\"animation\");\n/**\n* get string \"keyframes\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {KEYFRAMES} from \"@daybrush/utils\";\n\nconsole.log(KEYFRAMES); // \"keyframes\", \"-ms-keyframes\", \"-webkit-keyframes\"\n*/\n\nvar KEYFRAMES =\n/*#__PURE__*/\nANIMATION.replace(\"animation\", \"keyframes\");\n\n/**\n* @namespace\n* @name Utils\n*/\n\n/**\n* Check the type that the value is undefined.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {boolean} true if the type is correct, false otherwise\n* @example\nimport {isUndefined} from \"@daybrush/utils\";\n\nconsole.log(isUndefined(undefined)); // true\nconsole.log(isUndefined(\"\")); // false\nconsole.log(isUndefined(1)); // false\nconsole.log(isUndefined(null)); // false\n*/\n\nfunction isUndefined(value) {\n  return typeof value === UNDEFINED;\n}\n/**\n* Check the type that the value is object.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isObject} from \"@daybrush/utils\";\n\nconsole.log(isObject({})); // true\nconsole.log(isObject(undefined)); // false\nconsole.log(isObject(\"\")); // false\nconsole.log(isObject(null)); // false\n*/\n\nfunction isObject(value) {\n  return value && typeof value === OBJECT;\n}\n/**\n* Check the type that the value is isArray.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isArray} from \"@daybrush/utils\";\n\nconsole.log(isArray([])); // true\nconsole.log(isArray({})); // false\nconsole.log(isArray(undefined)); // false\nconsole.log(isArray(null)); // false\n*/\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n/**\n* Check the type that the value is string.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isString} from \"@daybrush/utils\";\n\nconsole.log(isString(\"1234\")); // true\nconsole.log(isString(undefined)); // false\nconsole.log(isString(1)); // false\nconsole.log(isString(null)); // false\n*/\n\nfunction isString(value) {\n  return typeof value === STRING;\n}\n/**\n* Check the type that the value is function.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isFunction} from \"@daybrush/utils\";\n\nconsole.log(isFunction(function a() {})); // true\nconsole.log(isFunction(() => {})); // true\nconsole.log(isFunction(\"1234\")); // false\nconsole.log(isFunction(1)); // false\nconsole.log(isFunction(null)); // false\n*/\n\nfunction isFunction(value) {\n  return typeof value === FUNCTION;\n}\n/**\n* divide text by space.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {spliceSpace} from \"@daybrush/utils\";\n\nconsole.log(splitSpace(\"a b c d e f g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitSpace(\"'a,b' c 'd,e' f g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\n\nfunction splitSpace(text) {\n  // divide comma(,)\n  var matches = text.match(/(\"[^\"]*\")|('[^']*')|([^\\s()]*(?:\\((?:[^()]*|\\([^()]*\\))*\\))[^\\s()]*)|\\S+/g);\n  return matches || [];\n}\n/**\n* divide text by comma.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {splitComma} from \"@daybrush/utils\";\n\nconsole.log(splitComma(\"a,b,c,d,e,f,g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitComma(\"'a,b',c,'d,e',f,g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\n\nfunction splitComma(text) {\n  // divide comma(,)\n  // \"[^\"]*\"|'[^']*'\n  var matches = text.match(/(\"[^\"]*\"|'[^']*'|[^,\\s()]*\\((?:[^()]*|\\([^()]*\\))*\\)[^,\\s()]*|[^,])+/g);\n  return matches ? matches.map(function (str) {\n    return str.trim();\n  }) : [];\n}\n/**\n* divide text by bracket \"(\", \")\".\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {object} divided texts\n* @example\nimport {splitBracket} from \"@daybrush/utils\";\n\nconsole.log(splitBracket(\"a(1, 2)\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"\"}\nconsole.log(splitBracket(\"a(1, 2)b\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"b\"}\n*/\n\nfunction splitBracket(text) {\n  var matches = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(text);\n\n  if (!matches || matches.length < 4) {\n    return {};\n  } else {\n    return {\n      prefix: matches[1],\n      value: matches[2],\n      suffix: matches[3]\n    };\n  }\n}\n/**\n* divide text by number and unit.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {} divided texts\n* @example\nimport {splitUnit} from \"@daybrush/utils\";\n\nconsole.log(splitUnit(\"10px\"));\n// {prefix: \"\", value: 10, unit: \"px\"}\nconsole.log(splitUnit(\"-10px\"));\n// {prefix: \"\", value: -10, unit: \"px\"}\nconsole.log(splitUnit(\"a10%\"));\n// {prefix: \"a\", value: 10, unit: \"%\"}\n*/\n\nfunction splitUnit(text) {\n  var matches = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(text);\n\n  if (!matches) {\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  }\n\n  var prefix = matches[1];\n  var value = matches[2];\n  var unit = matches[3];\n  return {\n    prefix: prefix,\n    unit: unit,\n    value: parseFloat(value)\n  };\n}\n/**\n* transform strings to camel-case\n* @memberof Utils\n* @param {String} text - string\n* @return {String} camel-case string\n* @example\nimport {camelize} from \"@daybrush/utils\";\n\nconsole.log(camelize(\"transform-origin\")); // transformOrigin\nconsole.log(camelize(\"abcd_efg\")); // abcdEfg\nconsole.log(camelize(\"abcd efg\")); // abcdEfg\n*/\n\nfunction camelize(str) {\n  return str.replace(/[\\s-_]([a-z])/g, function (all, letter) {\n    return letter.toUpperCase();\n  });\n}\n/**\n* transform a camelized string into a lowercased string.\n* @memberof Utils\n* @param {string} text - a camel-cased string\n* @param {string} [separator=\"-\"] - a separator\n* @return {string}  a lowercased string\n* @example\nimport {decamelize} from \"@daybrush/utils\";\n\nconsole.log(decamelize(\"transformOrigin\")); // transform-origin\nconsole.log(decamelize(\"abcdEfg\", \"_\")); // abcd_efg\n*/\n\nfunction decamelize(str, separator) {\n  if (separator === void 0) {\n    separator = \"-\";\n  }\n\n  return str.replace(/([a-z])([A-Z])/g, function (all, letter, letter2) {\n    return \"\" + letter + separator + letter2.toLowerCase();\n  });\n}\n/**\n* transforms something in an array into an array.\n* @memberof Utils\n* @param - Array form\n* @return an array\n* @example\nimport {toArray} from \"@daybrush/utils\";\n\nconst arr1 = toArray(document.querySelectorAll(\".a\")); // Element[]\nconst arr2 = toArray(document.querySelectorAll<HTMLElement>(\".a\")); // HTMLElement[]\n*/\n\nfunction toArray(value) {\n  return [].slice.call(value);\n}\n/**\n* Date.now() method\n* @memberof CrossBrowser\n* @return {number} milliseconds\n* @example\nimport {now} from \"@daybrush/utils\";\n\nconsole.log(now()); // 12121324241(milliseconds)\n*/\n\nfunction now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\n/**\n* window.requestAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.\n* @return {number} id\n* @example\nimport {requestAnimationFrame} from \"@daybrush/utils\";\n\nrequestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n*/\n\nvar requestAnimationFrame =\n/*#__PURE__*/\nfunction () {\n  var firstTime = now();\n  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame);\n  return raf ? raf.bind(window) : function (callback) {\n    var currTime = now();\n    var id = window.setTimeout(function () {\n      callback(currTime - firstTime);\n    }, 1000 / 60);\n    return id;\n  };\n}();\n\n/**\n* @namespace\n* @name Color\n*/\n\n/**\n* Remove the # from the hex color.\n* @memberof Color\n* @param {} hex - hex color\n* @return {} hex color\n* @example\nimport {cutHex} from \"@daybrush/utils\";\n\nconsole.log(cutHex(\"#000000\")) // \"000000\"\n*/\n\nfunction cutHex(hex) {\n  return hex.replace(\"#\", \"\");\n}\n/**\n* convert hex color to rgb color.\n* @memberof Color\n* @param {} hex - hex color\n* @return {} rgb color\n* @example\nimport {hexToRGBA} from \"@daybrush/utils\";\n\nconsole.log(hexToRGBA(\"#00000005\"));\n// [0, 0, 0, 1]\nconsole.log(hexToRGBA(\"#201045\"));\n// [32, 16, 69, 1]\n*/\n\nfunction hexToRGBA(hex) {\n  var h = cutHex(hex);\n  var r = parseInt(h.substring(0, 2), 16);\n  var g = parseInt(h.substring(2, 4), 16);\n  var b = parseInt(h.substring(4, 6), 16);\n  var a = parseInt(h.substring(6, 8), 16) / 255;\n\n  if (isNaN(a)) {\n    a = 1;\n  }\n\n  return [r, g, b, a];\n}\n/**\n* convert 3(or 4)-digit hex color to 6(or 8)-digit hex color.\n* @memberof Color\n* @param {} hex - 3(or 4)-digit hex color\n* @return {} 6(or 8)-digit hex color\n* @example\nimport {toFullHex} from \"@daybrush/utils\";\n\nconsole.log(toFullHex(\"#123\")); // \"#112233\"\nconsole.log(toFullHex(\"#123a\")); // \"#112233aa\"\n*/\n\nfunction toFullHex(h) {\n  var r = h.charAt(1);\n  var g = h.charAt(2);\n  var b = h.charAt(3);\n  var a = h.charAt(4);\n  var arr = [\"#\", r, r, g, g, b, b, a, a];\n  return arr.join(\"\");\n}\n/**\n* convert hsl color to rgba color.\n* @memberof Color\n* @param {} hsl - hsl color(hue: 0 ~ 360, saturation: 0 ~ 1, lightness: 0 ~ 1, alpha: 0 ~ 1)\n* @return {} rgba color\n* @example\nimport {hslToRGBA} from \"@daybrush/utils\";\n\nconsole.log(hslToRGBA([150, 0.5, 0.4]));\n// [51, 153, 102, 1]\n*/\n\nfunction hslToRGBA(hsl) {\n  var h = hsl[0];\n  var s = hsl[1];\n  var l = hsl[2];\n\n  if (h < 0) {\n    h += Math.floor((Math.abs(h) + 360) / 360) * 360;\n  }\n\n  h %= 360;\n  var c = (1 - Math.abs(2 * l - 1)) * s;\n  var x = c * (1 - Math.abs(h / 60 % 2 - 1));\n  var m = l - c / 2;\n  var rgb;\n\n  if (h < 60) {\n    rgb = [c, x, 0];\n  } else if (h < 120) {\n    rgb = [x, c, 0];\n  } else if (h < 180) {\n    rgb = [0, c, x];\n  } else if (h < 240) {\n    rgb = [0, x, c];\n  } else if (h < 300) {\n    rgb = [x, 0, c];\n  } else if (h < 360) {\n    rgb = [c, 0, x];\n  }\n\n  var result = [Math.round((rgb[0] + m) * 255), Math.round((rgb[1] + m) * 255), Math.round((rgb[2] + m) * 255), hsl.length > 3 ? hsl[3] : 1];\n  return result;\n}\n/**\n* convert string to rgba color.\n* @memberof Color\n* @param {} - 3-hex(#000), 4-hex(#0000) 6-hex(#000000), 8-hex(#00000000) or RGB(A), or HSL(A)\n* @return {} rgba color\n* @example\nimport {stringToRGBA} from \"@daybrush/utils\";\n\nconsole.log(stringToRGBA(\"#000000\")); // [0, 0, 0, 1]\nconsole.log(stringToRGBA(\"rgb(100, 100, 100)\")); // [100, 100, 100, 1]\nconsole.log(stringToRGBA(\"hsl(150, 0.5, 0.4)\")); // [51, 153, 102, 1]\n*/\n\nfunction stringToRGBA(color) {\n  if (color.charAt(0) === \"#\") {\n    if (color.length === 4 || color.length === 5) {\n      return hexToRGBA(toFullHex(color));\n    } else {\n      return hexToRGBA(color);\n    }\n  } else if (color.indexOf(\"(\") !== -1) {\n    // in bracket.\n    var _a = splitBracket(color),\n        prefix = _a.prefix,\n        value = _a.value;\n\n    if (!prefix || !value) {\n      return;\n    }\n\n    var arr = splitComma(value);\n    var colorArr = [];\n    var length = arr.length;\n\n    switch (prefix) {\n      case RGB:\n      case RGBA:\n        for (var i = 0; i < length; ++i) {\n          colorArr[i] = parseFloat(arr[i]);\n        }\n\n        return colorArr;\n\n      case HSL:\n      case HSLA:\n        for (var i = 0; i < length; ++i) {\n          if (arr[i].indexOf(\"%\") !== -1) {\n            colorArr[i] = parseFloat(arr[i]) / 100;\n          } else {\n            colorArr[i] = parseFloat(arr[i]);\n          }\n        } // hsl, hsla to rgba\n\n\n        return hslToRGBA(colorArr);\n    }\n  }\n\n  return;\n}\n\n/**\n * Returns all element descendants of node that\n * match selectors.\n */\n\n/**\n * Checks if the specified class value exists in the element's class attribute.\n * @memberof DOM\n * @param - A DOMString containing one or more selectors to match\n * @param - If multi is true, a DOMString containing one or more selectors to match against.\n * @example\nimport {$} from \"@daybrush/utils\";\n\nconsole.log($(\"div\")); // div element\nconsole.log($(\"div\", true)); // [div, div] elements\n*/\n\nfunction $(selectors, multi) {\n  return multi ? doc.querySelectorAll(selectors) : doc.querySelector(selectors);\n}\n/**\n* Checks if the specified class value exists in the element's class attribute.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to search\n* @return {boolean} return false if the class is not found.\n* @example\nimport {hasClass} from \"@daybrush/utils\";\n\nconsole.log(hasClass(element, \"start\")); // true or false\n*/\n\nfunction hasClass(element, className) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  }\n\n  return !!element.className.match(new RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\"));\n}\n/**\n* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to add\n* @example\nimport {addClass} from \"@daybrush/utils\";\n\naddClass(element, \"start\");\n*/\n\nfunction addClass(element, className) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    element.className += \" \" + className;\n  }\n}\n/**\n* Removes the specified class value.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to remove\n* @example\nimport {removeClass} from \"@daybrush/utils\";\n\nremoveClass(element, \"start\");\n*/\n\nfunction removeClass(element, className) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    var reg = new RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\");\n    element.className = element.className.replace(reg, \" \");\n  }\n}\n/**\n* Gets the CSS properties from the element.\n* @memberof DOM\n* @param elements - elements\n* @param properites - the CSS properties\n* @return returns CSS properties and values.\n* @example\nimport {fromCSS} from \"@daybrush/utils\";\n\nconsole.log(fromCSS(element, [\"left\", \"opacity\", \"top\"])); // {\"left\": \"10px\", \"opacity\": 1, \"top\": \"10px\"}\n*/\n\nfunction fromCSS(elements, properties) {\n  if (!elements || !properties || !properties.length) {\n    return {};\n  }\n\n  var element;\n\n  if (elements instanceof Element) {\n    element = elements;\n  } else if (elements.length) {\n    element = elements[0];\n  } else {\n    return {};\n  }\n\n  var cssObject = {};\n  var styles = window.getComputedStyle(element);\n  var length = properties.length;\n\n  for (var i = 0; i < length; ++i) {\n    cssObject[properties[i]] = styles[properties[i]];\n  }\n\n  return cssObject;\n}\n/**\n* Sets up a function that will be called whenever the specified event is delivered to the target\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs\n* @param - An options object that specifies characteristics about the event listener. The available options are:\n* @example\nimport {addEvent} from \"@daybrush/utils\";\n\naddEvent(el, \"click\", e => {\n  console.log(e);\n});\n*/\n\nfunction addEvent(el, type, listener, options) {\n  el.addEventListener(type, listener, options);\n}\n/**\n* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The EventListener function of the event handler to remove from the event target.\n* @example\nimport {addEvent, removeEvent} from \"@daybrush/utils\";\nconst listener = e => {\n  console.log(e);\n};\naddEvent(el, \"click\", listener);\nremoveEvent(el, \"click\", listener);\n*/\n\nfunction removeEvent(el, type, listener) {\n  el.removeEventListener(type, listener);\n}\n\nexport { RGB, RGBA, HSL, HSLA, COLOR_MODELS, FUNCTION, PROPERTY, ARRAY, OBJECT, STRING, NUMBER, UNDEFINED, IS_WINDOW, doc as document, getCrossBrowserProperty, TRANSFORM, FILTER, ANIMATION, KEYFRAMES, cutHex, hexToRGBA, toFullHex, hslToRGBA, stringToRGBA, isUndefined, isObject, isArray, isString, isFunction, splitSpace, splitComma, splitBracket, splitUnit, camelize, decamelize, toArray, now, requestAnimationFrame, $, hasClass, addClass, removeClass, fromCSS, addEvent, removeEvent };\n//# sourceMappingURL=utils.esm.js.map\n","/*\nCopyright (c) 2019 Daybrush\nname: scenejs\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/scenejs.git\nversion: 1.0.0-rc8\n*/\nimport { isObject, isArray, toArray, isString, $, document, IS_WINDOW, ANIMATION, removeEvent, addEvent, OBJECT, ARRAY, PROPERTY, STRING, NUMBER, splitComma, splitSpace, splitBracket, COLOR_MODELS, stringToRGBA, RGBA, requestAnimationFrame, splitUnit, camelize, isUndefined, TRANSFORM, FILTER, FUNCTION, fromCSS, isFunction, KEYFRAMES, addClass, removeClass, hasClass, decamelize } from '@daybrush/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction cubic(y1, y2, t) {\n  var t2 = 1 - t; // Bezier Curve Formula\n\n  return t * t * t + 3 * t * t * t2 * y2 + 3 * t * t2 * t2 * y1;\n}\n\nfunction solveFromX(x1, x2, x) {\n  // x  0 ~ 1\n  // t 0 ~ 1\n  var t = x;\n  var solveX = x;\n  var dx = 1;\n\n  while (Math.abs(dx) > 1 / 1000) {\n    // 예상 t초에 의한 _x값\n    solveX = cubic(x1, x2, t);\n    dx = solveX - x; // 차이가 미세하면 그 값을 t로 지정\n\n    if (Math.abs(dx) < 1 / 1000) {\n      return t;\n    }\n\n    t -= dx / 2;\n  }\n\n  return t;\n}\n/**\n * @namespace easing\n */\n\n/**\n* Cubic Bezier curve.\n* @memberof easing\n* @func bezier\n* @param {number} [x1] - point1's x\n* @param {number} [y1] - point1's y\n* @param {number} [x2] - point2's x\n* @param {number} [y2] - point2's y\n* @return {function} the curve function\n* @example\nimport {bezier} from \"scenejs\";\nScene.bezier(0, 0, 1, 1) // LINEAR\nScene.bezier(0.25, 0.1, 0.25, 1) // EASE\n*/\n\n\nfunction bezier(x1, y1, x2, y2) {\n  /*\n        x = f(t)\n        calculate inverse function by x\n        t = f-1(x)\n    */\n  var func = function (x) {\n    var t = solveFromX(x1, x2, Math.max(Math.min(1, x), 0));\n    return cubic(y1, y2, t);\n  };\n\n  func.easingName = \"cubic-bezier(\" + x1 + \",\" + y1 + \",\" + x2 + \",\" + y2 + \")\";\n  return func;\n}\n/**\n* Specifies a stepping function\n* @see {@link https://www.w3schools.com/cssref/css3_pr_animation-timing-function.asp|CSS3 Timing Function}\n* @memberof easing\n* @func steps\n* @param {number} count - point1's x\n* @param {\"start\" | \"end\"} postion - point1's y\n* @return {function} the curve function\n* @example\nimport {steps} from \"scenejs\";\nScene.steps(1, \"start\") // Scene.STEP_START\nScene.steps(1, \"end\") // Scene.STEP_END\n*/\n\nfunction steps(count, position) {\n  var func = function (time) {\n    var level = 1 / count;\n\n    if (time >= 1) {\n      return 1;\n    }\n\n    return (position === \"start\" ? level : 0) + Math.floor(time / level) * level;\n  };\n\n  func.easingName = \"steps(\" + count + \", \" + position + \")\";\n  return func;\n}\n/**\n* Equivalent to steps(1, start)\n* @memberof easing\n* @name STEP_START\n* @static\n* @type {function}\n* @example\nimport {STEP_START} from \"scenejs\";\nScene.STEP_START // steps(1, start)\n*/\n\nvar STEP_START =\n/*#__PURE__#*/\nsteps(1, \"start\");\n/**\n* Equivalent to steps(1, end)\n* @memberof easing\n* @name STEP_END\n* @static\n* @type {function}\n* @example\nimport {STEP_END} from \"scenejs\";\nScene.STEP_END // steps(1, end)\n*/\n\nvar STEP_END =\n/*#__PURE__#*/\nsteps(1, \"end\");\n/**\n* Linear Speed (0, 0, 1, 1)\n* @memberof easing\n* @name LINEAR\n* @static\n* @type {function}\n* @example\nimport {LINEAR} from \"scenejs\";\nScene.LINEAR\n*/\n\nvar LINEAR =\n/*#__PURE__#*/\nbezier(0, 0, 1, 1);\n/**\n* Ease Speed (0.25, 0.1, 0.25, 1)\n* @memberof easing\n* @name EASE\n* @static\n* @type {function}\n* @example\nimport {EASE} from \"scenejs\";\nScene.EASE\n*/\n\nvar EASE =\n/*#__PURE__#*/\nbezier(0.25, 0.1, 0.25, 1);\n/**\n* Ease In Speed (0.42, 0, 1, 1)\n* @memberof easing\n* @name EASE_IN\n* @static\n* @type {function}\n* @example\nimport {EASE_IN} from \"scenejs\";\nScene.EASE_IN\n*/\n\nvar EASE_IN =\n/*#__PURE__#*/\nbezier(0.42, 0, 1, 1);\n/**\n* Ease Out Speed (0, 0, 0.58, 1)\n* @memberof easing\n* @name EASE_OUT\n* @static\n* @type {function}\n* @example\nimport {EASE_OUT} from \"scenejs\";\nScene.EASE_OUT\n*/\n\nvar EASE_OUT =\n/*#__PURE__#*/\nbezier(0, 0, 0.58, 1);\n/**\n* Ease In Out Speed (0.42, 0, 0.58, 1)\n* @memberof easing\n* @name EASE_IN_OUT\n* @static\n* @type {function}\n* @example\nimport {EASE_IN_OUT} from \"scenejs\";\nScene.EASE_IN_OUT\n*/\n\nvar EASE_IN_OUT =\n/*#__PURE__#*/\nbezier(0.42, 0, 0.58, 1);\n\nvar PREFIX = \"__SCENEJS_\";\nvar DATA_SCENE_ID = \"data-scene-id\";\nvar TIMING_FUNCTION = \"animation-timing-function\";\nvar ROLES = {\n  transform: {},\n  filter: {},\n  attribute: {}\n};\nvar ALIAS = {\n  easing: [TIMING_FUNCTION]\n};\nvar FIXED = (_a = {}, _a[TIMING_FUNCTION] = true, _a.contents = true, _a);\nvar MAXIMUM = 1000000;\nvar THRESHOLD = 0.000001;\nvar DURATION = \"duration\";\nvar FILL_MODE = \"fillMode\";\nvar DIRECTION = \"direction\";\nvar ITERATION_COUNT = \"iterationCount\";\nvar DELAY = \"delay\";\nvar EASING = \"easing\";\nvar PLAY_SPEED = \"playSpeed\";\nvar EASING_NAME = \"easingName\";\nvar ITERATION_TIME = \"iterationTime\";\nvar PAUSED = \"paused\";\nvar ENDED = \"ended\";\nvar TIMEUPDATE = \"timeupdate\";\nvar ANIMATE = \"animate\";\nvar PLAY = \"play\";\nvar RUNNING = \"running\";\nvar ITERATION = \"iteration\";\nvar START_ANIMATION = \"startAnimation\";\nvar PAUSE_ANIMATION = \"pauseAnimation\";\nvar ALTERNATE = \"alternate\";\nvar REVERSE = \"reverse\";\nvar ALTERNATE_REVERSE = \"alternate-reverse\";\nvar NORMAL = \"normal\";\nvar INFINITE = \"infinite\";\nvar PLAY_STATE = \"playState\";\nvar PLAY_CSS = \"playCSS\";\nvar PREV_TIME = \"prevTime\";\nvar TICK_TIME = \"tickTime\";\nvar CURRENT_TIME = \"currentTime\";\nvar SELECTOR = \"selector\";\nvar TRANSFORM_NAME = \"transform\";\nvar EASINGS = {\n  \"linear\": LINEAR,\n  \"ease\": EASE,\n  \"ease-in\": EASE_IN,\n  \"ease-out\": EASE_OUT,\n  \"ease-in-out\": EASE_IN_OUT,\n  \"step-start\": STEP_START,\n  \"step-end\": STEP_END\n};\n/**\n* option name list\n* @name Scene.OPTIONS\n* @memberof Scene\n* @static\n* @type {$ts:OptionType}\n* @example\n* Scene.OPTIONS // [\"duration\", \"fillMode\", \"direction\", \"iterationCount\", \"delay\", \"easing\", \"playSpeed\"]\n*/\n\nvar OPTIONS = [DURATION, FILL_MODE, DIRECTION, ITERATION_COUNT, DELAY, EASING, PLAY_SPEED];\n/**\n* Event name list\n* @name Scene.EVENTS\n* @memberof Scene\n* @static\n* @type {$ts:EventType}\n* @example\n* Scene.EVENTS // [\"paused\", \"ended\", \"timeupdate\", \"animate\", \"play\", \"iteration\"];\n*/\n\nvar EVENTS = [PAUSED, ENDED, TIMEUPDATE, ANIMATE, PLAY, ITERATION];\n\nvar _a;\n\n/**\n* attach and trigger event handlers.\n*/\n\nvar EventTrigger =\n/*#__PURE__*/\nfunction () {\n  /**\n    * @example\n  const et = new Scene.EventTrigger();\n  const scene = new Scene();\n  scene.on(\"call\", e => {\n    console.log(e.param);\n  });\n  et.on(\"call\", e => {\n    console.log(e.param);\n  });\n  scene.trigger(\"call\", {param: 1});\n  et.trigger(\"call\", {param: 1});\n     */\n  function EventTrigger() {\n    this.events = {};\n  }\n\n  var __proto = EventTrigger.prototype;\n\n  __proto._on = function (name, callback, once) {\n    var _this = this;\n\n    var events = this.events;\n\n    if (isObject(name)) {\n      for (var n in name) {\n        this._on(n, name[n], once);\n      }\n\n      return;\n    }\n\n    if (!(name in events)) {\n      events[name] = [];\n    }\n\n    if (!callback) {\n      return;\n    }\n\n    if (isArray(callback)) {\n      callback.forEach(function (func) {\n        return _this._on(name, func, once);\n      });\n      return;\n    }\n\n    events[name].push(once ? function callback2() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      callback.apply(void 0, args);\n      this.off(name, callback2);\n    } : callback);\n  };\n  /**\n    * Attach an event handler function for one or more events to target\n    * @param - event's name\n    * @param - function to execute when the event is triggered.\n    * @return {EventTrigger} An Instance itself.\n    * @example\n  target.on(\"animate\", function() {\n    console.log(\"animate\");\n  });\n  target.trigger(\"animate\");\n   */\n\n\n  __proto.on = function (name, callback) {\n    this._on(name, callback);\n\n    return this;\n  };\n  /**\n    * Dettach an event handler function for one or more events to target\n    * @param - event's name\n    * @param -  function to execute when the event is triggered.\n    * @return {EventTrigger} An Instance itself.\n    * @example\n  const callback = function() {\n    console.log(\"animate\");\n  };\n  target.on(\"animate\", callback);\n  target.off(\"animate\", callback);\n  target.off(\"animate\");\n     */\n\n\n  __proto.off = function (name, callback) {\n    if (!name) {\n      this.events = {};\n    } else if (!callback) {\n      this.events[name] = [];\n    } else {\n      var callbacks = this.events[name];\n\n      if (!callbacks) {\n        return this;\n      }\n\n      var index = callbacks.indexOf(callback);\n\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n    }\n\n    return this;\n  };\n  /**\n    * execute event handler\n    * @param - event's name\n    * @param - event handler's additional parameter\n    * @return {EventTrigger} An Instance itself.\n    * @example\n  target.on(\"animate\", function(a1, a2) {\n    console.log(\"animate\", a1, a2);\n  });\n  target.trigger(\"animate\", [1, 2]); // log => \"animate\", 1, 2\n     */\n\n\n  __proto.trigger = function (name) {\n    var _this = this;\n\n    var data = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      data[_i - 1] = arguments[_i];\n    }\n\n    var events = this.events;\n\n    if (!(name in events)) {\n      return this;\n    }\n\n    var args = data || [];\n    !args[0] && (args[0] = {});\n    var event = events[name];\n    var target = args[0];\n    target.type = name;\n    target.currentTarget = this;\n    !target.target && (target.target = this);\n    toArray(events[name]).forEach(function (callback) {\n      callback.apply(_this, data);\n    });\n    return this;\n  };\n\n  __proto.once = function (name, callback) {\n    this._on(name, callback, true);\n\n    return this;\n  };\n\n  return EventTrigger;\n}();\n\n/**\n* Make string, array to PropertyObject for the dot product\n*/\n\nvar PropertyObject =\n/*#__PURE__*/\nfunction () {\n  /**\n    * @param - This value is in the array format.\n    * @param - options\n    * @example\n  var obj = new PropertyObject([100,100,100,0.5], {\n    \"separator\" : \",\",\n    \"prefix\" : \"rgba(\",\n    \"suffix\" : \")\"\n  });\n     */\n  function PropertyObject(value, options) {\n    this.prefix = \"\";\n    this.suffix = \"\";\n    this.model = \"\";\n    this.type = \"\";\n    this.separator = \",\";\n    options && this.setOptions(options);\n    this.value = isString(value) ? value.split(this.separator) : value;\n  }\n\n  var __proto = PropertyObject.prototype;\n\n  __proto.setOptions = function (newOptions) {\n    for (var name in newOptions) {\n      this[name] = newOptions[name];\n    }\n\n    return this;\n  };\n  /**\n    * the number of values.\n    * @example\n  const obj1 = new PropertyObject(\"1,2,3\", \",\");\n  console.log(obj1.length);\n  // 3\n     */\n\n\n  __proto.size = function () {\n    return this.value.length;\n  };\n  /**\n    * retrieve one of values at the index\n    * @param {Number} index - index\n    * @return {Object} one of values at the index\n    * @example\n  const obj1 = new PropertyObject(\"1,2,3\", \",\");\n  console.log(obj1.get(0));\n  // 1\n     */\n\n\n  __proto.get = function (index) {\n    return this.value[index];\n  };\n  /**\n    * Set the value at that index\n    * @param {Number} index - index\n    * @param {Object} value - text, a number, object to set\n    * @return {PropertyObject} An instance itself\n    * @example\n  const obj1 = new PropertyObject(\"1,2,3\", \",\");\n  obj1.set(0, 2);\n  console.log(obj1.toValue());\n  // 2,2,3\n     */\n\n\n  __proto.set = function (index, value) {\n    this.value[index] = value;\n    return this;\n  };\n  /**\n    * create a copy of an instance itself.\n    * @return {PropertyObject} clone\n    * @example\n  const obj1 = new PropertyObject(\"1,2,3\", \",\");\n  const obj2 = obj1.clone();\n     */\n\n\n  __proto.clone = function () {\n    var _a = this,\n        separator = _a.separator,\n        prefix = _a.prefix,\n        suffix = _a.suffix,\n        model = _a.model,\n        type = _a.type;\n\n    var arr = this.value.map(function (v) {\n      return v instanceof PropertyObject ? v.clone() : v;\n    });\n    return new PropertyObject(arr, {\n      separator: separator,\n      prefix: prefix,\n      suffix: suffix,\n      model: model,\n      type: type\n    });\n  };\n  /**\n    * Make Property Object to String\n    * @return {String} Make Property Object to String\n    * @example\n  //rgba(100, 100, 100, 0.5)\n  const obj4 = new PropertyObject([100,100,100,0.5], {\n    \"separator\" : \",\",\n    \"prefix\" : \"rgba(\",\n    \"suffix\" : \")\",\n  });\n  console.log(obj4.toValue());\n  // \"rgba(100,100,100,0.5)\"\n    */\n\n\n  __proto.toValue = function () {\n    return this.prefix + this.join() + this.suffix;\n  };\n  /**\n    * Make Property Object's array to String\n    * @return {String} Join the elements of an array into a string\n    * @example\n    //rgba(100, 100, 100, 0.5)\n    var obj4 = new PropertyObject([100,100,100,0.5], {\n        \"separator\" : \",\",\n        \"prefix\" : \"rgba(\",\n        \"suffix\" : \")\"\n    });\n    obj4.join();  // =>   \"100,100,100,0.5\"\n     */\n\n\n  __proto.join = function () {\n    return this.value.map(function (v) {\n      return v instanceof PropertyObject ? v.toValue() : v;\n    }).join(this.separator);\n  };\n  /**\n    * executes a provided function once per array element.\n    * @param {Function} callback - Function to execute for each element, taking three arguments\n    * @param {All} [callback.currentValue] The current element being processed in the array.\n    * @param {Number} [callback.index] The index of the current element being processed in the array.\n    * @param {Array} [callback.array] the array.\n    * @return {PropertyObject} An instance itself\n    * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach|MDN Array.forEach()} reference to MDN document.\n    * @example\n  //rgba(100, 100, 100, 0.5)\n  var obj4 = new PropertyObject([100,100,100,0.5], {\n    \"separator\" : \",\",\n    \"prefix\" : \"rgba(\",\n    \"suffix\" : \")\"\n  });\n  obj4.forEach(t => {\n    console.log(t);\n  });  // =>   \"100,100,100,0.5\"\n    */\n\n\n  __proto.forEach = function (func) {\n    this.value.forEach(func);\n    return this;\n  };\n\n  return PropertyObject;\n}();\n\nfunction isPropertyObject(value) {\n  return value instanceof PropertyObject;\n}\nfunction setAlias(name, alias) {\n  ALIAS[name] = alias;\n}\nfunction setRole(names, isProperty, isFixedProperty) {\n  var length = names.length;\n  var roles = ROLES;\n  var fixed = FIXED;\n\n  for (var i = 0; i < length - 1; ++i) {\n    !roles[names[i]] && (roles[names[i]] = {});\n    roles = roles[names[i]];\n\n    if (isFixedProperty) {\n      !fixed[names[i]] && (fixed[names[i]] = {});\n      fixed = fixed[names[i]];\n    }\n  }\n\n  isFixedProperty && (fixed[names[length - 1]] = true);\n  roles[names[length - 1]] = isProperty ? true : {};\n}\nfunction getType(value) {\n  var type = typeof value;\n\n  if (type === OBJECT) {\n    if (isArray(value)) {\n      return ARRAY;\n    } else if (isPropertyObject(value)) {\n      return PROPERTY;\n    }\n  } else if (type === STRING || type === NUMBER) {\n    return \"value\";\n  }\n\n  return type;\n}\nfunction toFixed(num) {\n  return Math.round(num * MAXIMUM) / MAXIMUM;\n}\nfunction getValueByNames(names, properties, length) {\n  if (length === void 0) {\n    length = names.length;\n  }\n\n  var value = properties;\n\n  for (var i = 0; i < length; ++i) {\n    if (!isObject(value)) {\n      return undefined;\n    }\n\n    value = value[names[i]];\n  }\n\n  return value;\n}\nfunction isInProperties(roles, args, isCheckTrue) {\n  var length = args.length;\n  var role = roles;\n\n  if (length === 0) {\n    return false;\n  }\n\n  for (var i = 0; i < length; ++i) {\n    if (role === true) {\n      return false;\n    }\n\n    role = role[args[i]];\n\n    if (!role || !isCheckTrue && role === true) {\n      return false;\n    }\n  }\n\n  return true;\n}\nfunction isRole(args, isCheckTrue) {\n  return isInProperties(ROLES, args, isCheckTrue);\n}\nfunction isFixed(args) {\n  return isInProperties(FIXED, args, true);\n}\nfunction setPlayCSS(item, isActivate) {\n  item.state[PLAY_CSS] = isActivate;\n}\nfunction isPausedCSS(item) {\n  return item.state[PLAY_CSS] && item.isPaused();\n}\nfunction isEndedCSS(item) {\n  return !item.isEnded() && item.state[PLAY_CSS];\n}\nfunction exportCSS(id, css) {\n  var styleId = PREFIX + \"STYLE_\" + toId(id);\n  var styleElement = $(\"#\" + styleId);\n\n  if (styleElement) {\n    styleElement.innerText = css;\n  } else {\n    document.body.insertAdjacentHTML(\"beforeend\", \"<style id=\\\"\" + styleId + \"\\\">\" + css + \"</style>\");\n  }\n}\nfunction makeId(selector) {\n  for (;;) {\n    var id = \"\" + Math.floor(Math.random() * 10000000);\n\n    if (!IS_WINDOW || !selector) {\n      return id;\n    }\n\n    var checkElement = $(\"[data-scene-id=\\\"\" + id + \"\\\"]\");\n\n    if (!checkElement) {\n      return id;\n    }\n  }\n}\nfunction getRealId(item) {\n  return item.getId() || item.setId(makeId(false)).getId();\n}\nfunction toId(text) {\n  return (\"\" + text).match(/[0-9a-zA-Z]+/g).join(\"\");\n}\nfunction playCSS(item, isExportCSS, playClassName, properties) {\n  if (properties === void 0) {\n    properties = {};\n  }\n\n  if (!ANIMATION || item.getPlayState() === RUNNING) {\n    return;\n  }\n\n  var className = playClassName || START_ANIMATION;\n\n  if (isPausedCSS(item)) {\n    item.addPlayClass(true, className, properties);\n  } else {\n    if (item.isEnded()) {\n      item.setTime(0);\n    }\n\n    isExportCSS && item.exportCSS({\n      className: className\n    });\n    var el = item.addPlayClass(false, className, properties);\n\n    if (!el) {\n      return;\n    }\n\n    addAnimationEvent(item, el);\n    setPlayCSS(item, true);\n  }\n\n  item.setPlayState(RUNNING);\n}\nfunction findIndex(arr, callback, defaultIndex) {\n  if (defaultIndex === void 0) {\n    defaultIndex = -1;\n  }\n\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i])) {\n      return i;\n    }\n  }\n\n  return defaultIndex;\n}\nfunction find(arr, callback, defalutValue) {\n  var index = findIndex(arr, callback);\n  return index > -1 ? arr[index] : defalutValue;\n}\nfunction addAnimationEvent(item, el) {\n  var state = item.state;\n  var duration = item.getDuration();\n  var isZeroDuration = !duration || !isFinite(duration);\n\n  var animationend = function () {\n    setPlayCSS(item, false);\n    item.finish();\n  };\n\n  var animationstart = function () {\n    item.trigger(PLAY);\n  };\n\n  item.once(ENDED, function () {\n    removeEvent(el, \"animationcancel\", animationend);\n    removeEvent(el, \"animationend\", animationend);\n    removeEvent(el, \"animationiteration\", animationiteration);\n    removeEvent(el, \"animationstart\", animationstart);\n  });\n\n  var animationiteration = function (_a) {\n    var elapsedTime = _a.elapsedTime;\n    var currentTime = elapsedTime;\n    var iterationCount = isZeroDuration ? 0 : currentTime / duration;\n    state[CURRENT_TIME] = currentTime;\n    item.setIteration(iterationCount);\n  };\n\n  addEvent(el, \"animationcancel\", animationend);\n  addEvent(el, \"animationend\", animationend);\n  addEvent(el, \"animationiteration\", animationiteration);\n  addEvent(el, \"animationstart\", animationstart);\n}\n\n/**\n* @namespace\n* @name Property\n*/\nfunction splitStyle(str) {\n  var properties = str.split(\";\");\n  var obj = {};\n  var length = properties.length;\n\n  for (var i = 0; i < length; ++i) {\n    var matches = /([^:]*):([\\S\\s]*)/g.exec(properties[i]);\n\n    if (!matches || matches.length < 3 || !matches[1]) {\n      --length;\n      continue;\n    }\n\n    obj[matches[1].trim()] = toPropertyObject(matches[2].trim());\n  }\n\n  return {\n    styles: obj,\n    length: length\n  };\n}\n/**\n* convert array to PropertyObject[type=color].\n* default model \"rgba\"\n* @memberof Property\n* @function arrayToColorObject\n* @param {Array|PropertyObject} value ex) [0, 0, 0, 1]\n* @return {PropertyObject} PropertyObject[type=color]\n* @example\narrayToColorObject([0, 0, 0])\n// => PropertyObject(type=\"color\", model=\"rgba\", value=[0, 0, 0, 1], separator=\",\")\n*/\n\nfunction arrayToColorObject(arr) {\n  var model = RGBA;\n\n  if (arr.length === 3) {\n    arr[3] = 1;\n  }\n\n  return new PropertyObject(arr, {\n    model: model,\n    separator: \",\",\n    type: \"color\",\n    prefix: model + \"(\",\n    suffix: \")\"\n  });\n}\n/**\n* convert text with parentheses to object.\n* @memberof Property\n* @function stringToBracketObject\n* @param {String} value ex) \"rgba(0,0,0,1)\"\n* @return {PropertyObject} PropertyObject\n* @example\nstringToBracketObject(\"abcde(0, 0, 0,1)\")\n// => PropertyObject(model=\"abcde\", value=[0, 0, 0,1], separator=\",\")\n*/\n\nfunction stringToBracketObject(text) {\n  // [prefix, value, other]\n  var _a = splitBracket(text),\n      model = _a.prefix,\n      value = _a.value,\n      afterModel = _a.suffix;\n\n  if (typeof value === \"undefined\") {\n    return text;\n  }\n\n  if (COLOR_MODELS.indexOf(model) !== -1) {\n    return arrayToColorObject(stringToRGBA(text));\n  } // divide comma(,)\n\n\n  var obj = toPropertyObject(value);\n  var arr = [value];\n  var separator = \",\";\n  var prefix = model + \"(\";\n  var suffix = \")\" + afterModel;\n\n  if (obj instanceof PropertyObject) {\n    separator = obj.separator;\n    arr = obj.value;\n    prefix += obj.prefix;\n    suffix = obj.suffix + suffix;\n  }\n\n  return new PropertyObject(arr, {\n    separator: separator,\n    model: model,\n    prefix: prefix,\n    suffix: suffix\n  });\n}\nfunction arrayToPropertyObject(arr, separator) {\n  return new PropertyObject(arr, {\n    type: \"array\",\n    separator: separator\n  });\n}\n/**\n* convert text with parentheses to PropertyObject[type=color].\n* If the values are not RGBA model, change them RGBA mdoel.\n* @memberof Property\n* @function stringToColorObject\n* @param {String|PropertyObject} value ex) \"rgba(0,0,0,1)\"\n* @return {PropertyObject} PropertyObject[type=color]\n* @example\nstringToColorObject(\"rgba(0, 0, 0,1)\")\n// => PropertyObject(type=\"color\", model=\"rgba\", value=[0, 0, 0,1], separator=\",\")\n*/\n\nfunction stringToColorObject(value) {\n  var result = stringToRGBA(value);\n  return result ? arrayToColorObject(result) : value;\n}\nfunction toPropertyObject(value) {\n  if (!isString(value)) {\n    if (isArray(value)) {\n      return arrayToPropertyObject(value, \",\");\n    }\n\n    return value;\n  }\n\n  var values = splitComma(value);\n\n  if (values.length > 1) {\n    return arrayToPropertyObject(values.map(function (v) {\n      return toPropertyObject(v);\n    }), \",\");\n  }\n\n  values = splitSpace(value);\n\n  if (values.length > 1) {\n    return arrayToPropertyObject(values.map(function (v) {\n      return toPropertyObject(v);\n    }), \" \");\n  }\n\n  values = /^(['\"])([^'\"]*)(['\"])$/g.exec(value);\n\n  if (values && values[1] === values[3]) {\n    // Quotes\n    return new PropertyObject([toPropertyObject(values[2])], {\n      prefix: values[1],\n      suffix: values[1]\n    });\n  } else if (value.indexOf(\"(\") !== -1) {\n    // color\n    return stringToBracketObject(value);\n  } else if (value.charAt(0) === \"#\") {\n    return stringToColorObject(value);\n  }\n\n  return value;\n}\nfunction toObject(object, result) {\n  if (result === void 0) {\n    result = {};\n  }\n\n  var model = object.model;\n\n  if (model) {\n    object.setOptions({\n      model: \"\",\n      suffix: \"\",\n      prefix: \"\"\n    });\n    var value = object.size() > 1 ? object : object.get(0);\n    result[model] = value;\n  } else {\n    object.forEach(function (obj) {\n      toObject(obj, result);\n    });\n  }\n\n  return result;\n}\n\nfunction GetterSetter(getter, setter, parent) {\n  return function (constructor) {\n    var prototype = constructor.prototype;\n    getter.forEach(function (name) {\n      prototype[camelize(\"get \" + name)] = function () {\n        return this[parent][name];\n      };\n    });\n    setter.forEach(function (name) {\n      prototype[camelize(\"set \" + name)] = function (value) {\n        this[parent][name] = value;\n        return this;\n      };\n    });\n  };\n}\n\nfunction tick(animator, now, to) {\n  if (animator.isPaused()) {\n    return;\n  }\n\n  var state = animator.state;\n  var playSpeed = state[PLAY_SPEED];\n  var prevTime = state[PREV_TIME];\n  var delay = state[DELAY];\n  var tickTime = state[TICK_TIME];\n  var currentTime = tickTime + Math.min(1000, now - prevTime) / 1000 * playSpeed;\n  state[PREV_TIME] = now;\n  animator.setTime(currentTime - delay, true);\n\n  if (to && to * 1000 < now) {\n    animator.pause();\n  }\n\n  if (state[PLAY_STATE] === PAUSED) {\n    return;\n  }\n\n  requestAnimationFrame(function (time) {\n    tick(animator, time, to);\n  });\n}\n\nfunction isDirectionReverse(iteration, iteraiontCount, direction) {\n  if (direction === REVERSE) {\n    return true;\n  } else if (iteraiontCount !== INFINITE && iteration === iteraiontCount && iteraiontCount % 1 === 0) {\n    return direction === (iteration % 2 >= 1 ? ALTERNATE_REVERSE : ALTERNATE);\n  }\n\n  return direction === (iteration % 2 >= 1 ? ALTERNATE : ALTERNATE_REVERSE);\n}\n/**\n* @typedef {Object} AnimatorState The Animator options. Properties used in css animation.\n* @property {number} [duration] The duration property defines how long an animation should take to complete one cycle.\n* @property {\"none\"|\"forwards\"|\"backwards\"|\"both\"} [fillMode] The fillMode property specifies a style for the element when the animation is not playing (before it starts, after it ends, or both).\n* @property {\"infinite\"|number} [iterationCount] The iterationCount property specifies the number of times an animation should be played.\n* @property {array|function} [easing] The easing(timing-function) specifies the speed curve of an animation.\n* @property {number} [delay] The delay property specifies a delay for the start of an animation.\n* @property {\"normal\"|\"reverse\"|\"alternate\"|\"alternate-reverse\"} [direction] The direction property defines whether an animation should be played forwards, backwards or in alternate cycles.\n*/\n\nvar setters = [\"id\", ITERATION_COUNT, DELAY, FILL_MODE, DIRECTION, PLAY_SPEED, DURATION, PLAY_SPEED, ITERATION_TIME, PLAY_STATE];\nvar getters = setters.concat([EASING, EASING_NAME]);\n/**\n* play video, animation, the others\n* @extends EventTrigger\n* @see {@link https://www.w3schools.com/css/css3_animations.asp|CSS3 Animation}\n*/\n\nvar Animator =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Animator, _super);\n  /**\n   * @param - animator's options\n   * @example\n  const animator = new Animator({\n    delay: 2,\n    diretion: \"alternate\",\n    duration: 2,\n    fillMode: \"forwards\",\n    iterationCount: 3,\n    easing: Scene.easing.EASE,\n  });\n   */\n\n\n  function Animator(options) {\n    var _this = _super.call(this) || this;\n\n    _this.state = {\n      id: \"\",\n      easing: 0,\n      easingName: \"linear\",\n      iterationCount: 1,\n      delay: 0,\n      fillMode: \"forwards\",\n      direction: NORMAL,\n      playSpeed: 1,\n      currentTime: 0,\n      iterationTime: -1,\n      iteration: 0,\n      tickTime: 0,\n      prevTime: 0,\n      playState: PAUSED,\n      duration: 0\n    };\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n  /**\n    * set animator's easing.\n    * @param curverArray - The speed curve of an animation.\n    * @return {Animator} An instance itself.\n    * @example\n  animator.({\n    delay: 2,\n    diretion: \"alternate\",\n    duration: 2,\n    fillMode: \"forwards\",\n    iterationCount: 3,\n    easing: Scene.easing.EASE,\n  });\n    */\n\n\n  var __proto = Animator.prototype;\n\n  __proto.setEasing = function (curveArray) {\n    var easing;\n\n    if (isString(curveArray)) {\n      if (curveArray in EASINGS) {\n        easing = EASINGS[curveArray];\n      } else {\n        var obj = toPropertyObject(curveArray);\n\n        if (isString(obj)) {\n          return this;\n        } else {\n          if (obj.model === \"cubic-bezier\") {\n            curveArray = obj.value.map(function (v) {\n              return parseFloat(v);\n            });\n            easing = bezier(curveArray[0], curveArray[1], curveArray[2], curveArray[3]);\n          } else if (obj.model === \"steps\") {\n            easing = steps(parseFloat(obj.value[0]), obj.value[1]);\n          } else {\n            return this;\n          }\n        }\n      }\n    } else if (isArray(curveArray)) {\n      easing = bezier(curveArray[0], curveArray[1], curveArray[2], curveArray[3]);\n    } else {\n      easing = curveArray;\n    }\n\n    var easingName = easing[EASING_NAME] || \"linear\";\n    var state = this.state;\n    state[EASING] = easing;\n    state[EASING_NAME] = easingName;\n    return this;\n  };\n  /**\n    * set animator's options.\n    * @see {@link https://www.w3schools.com/css/css3_animations.asp|CSS3 Animation}\n    * @param - animator's options\n    * @return {Animator} An instance itself.\n    * @example\n  animator.({\n    delay: 2,\n    diretion: \"alternate\",\n    duration: 2,\n    fillMode: \"forwards\",\n    iterationCount: 3,\n    easing: Scene.eaasing.EASE,\n  });\n    */\n\n\n  __proto.setOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    for (var name in options) {\n      var value = options[name];\n\n      if (name === EASING) {\n        this.setEasing(value);\n        continue;\n      } else if (name === DURATION) {\n        value && this.setDuration(value);\n        continue;\n      }\n\n      if (OPTIONS.indexOf(name) > -1) {\n        this.state[name] = value;\n      }\n    }\n\n    return this;\n  };\n  /**\n    * Get the animator's total duration including delay\n    * @return {number} Total duration\n    * @example\n  animator.getTotalDuration();\n    */\n\n\n  __proto.getTotalDuration = function () {\n    return this.getActiveDuration(true);\n  };\n  /**\n    * Get the animator's total duration excluding delay\n    * @return {number} Total duration excluding delay\n    * @example\n  animator.getActiveDuration();\n    */\n\n\n  __proto.getActiveDuration = function (delay) {\n    var state = this.state;\n    var count = state[ITERATION_COUNT];\n\n    if (count === INFINITE) {\n      return Infinity;\n    }\n\n    return (delay ? state[DELAY] : 0) + this.getDuration() * count;\n  };\n  /**\n    * Check if the animator has reached the end.\n    * @return {boolean} ended\n    * @example\n  animator.isEnded(); // true or false\n    */\n\n\n  __proto.isEnded = function () {\n    if (this.state[TICK_TIME] === 0 && this.state[PLAY_STATE] === PAUSED) {\n      return true;\n    } else if (this.getTime() < this.getActiveDuration()) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n    *Check if the animator is paused:\n    * @return {boolean} paused\n    * @example\n  animator.isPaused(); // true or false\n    */\n\n\n  __proto.isPaused = function () {\n    return this.state[PLAY_STATE] === PAUSED;\n  };\n\n  __proto.start = function (delay) {\n    if (delay === void 0) {\n      delay = this.state[DELAY];\n    }\n\n    var state = this.state;\n    state[PLAY_STATE] = RUNNING;\n\n    if (state[TICK_TIME] >= delay) {\n      /**\n       * This event is fired when play animator.\n       * @event Animator#play\n       */\n      this.trigger(PLAY);\n    }\n  };\n  /**\n    * play animator\n    * @return {Animator} An instance itself.\n    */\n\n\n  __proto.play = function (toTime) {\n    var _this = this;\n\n    var state = this.state;\n    var delay = state[DELAY];\n    var currentTime = this.getTime();\n    state[PLAY_STATE] = RUNNING;\n\n    if (this.isEnded() && (currentTime === 0 || currentTime >= this.getActiveDuration())) {\n      this.setTime(-delay, true);\n    }\n\n    state[TICK_TIME] = this.getTime();\n    requestAnimationFrame(function (time) {\n      state[PREV_TIME] = time;\n      tick(_this, time, toTime);\n    });\n    this.start();\n    return this;\n  };\n  /**\n    * pause animator\n    * @return {Animator} An instance itself.\n    */\n\n\n  __proto.pause = function () {\n    var state = this.state;\n\n    if (state[PLAY_STATE] !== PAUSED) {\n      state[PLAY_STATE] = PAUSED;\n      /**\n       * This event is fired when animator is paused.\n       * @event Animator#paused\n       */\n\n      this.trigger(PAUSED);\n    }\n\n    return this;\n  };\n  /**\n     * end animator\n     * @return {Animator} An instance itself.\n    */\n\n\n  __proto.finish = function () {\n    this.setTime(0);\n    this.state[TICK_TIME] = 0;\n    this.end();\n    return this;\n  };\n  /**\n     * end animator\n     * @return {Animator} An instance itself.\n    */\n\n\n  __proto.end = function () {\n    this.pause();\n    /**\n         * This event is fired when animator is ended.\n         * @event Animator#ended\n         */\n\n    this.trigger(ENDED);\n    return this;\n  };\n  /**\n    * set currentTime\n    * @param {Number|String} time - currentTime\n    * @return {Animator} An instance itself.\n    * @example\n  animator.setTime(\"from\"); // 0\n  animator.setTime(\"to\"); // 100%\n  animator.setTime(\"50%\");\n  animator.setTime(10);\n  animator.getTime() // 10\n    */\n\n\n  __proto.setTime = function (time, isTick) {\n    var activeDuration = this.getActiveDuration();\n    var state = this.state;\n    var prevTime = state[TICK_TIME];\n    var delay = state[DELAY];\n    var currentTime = isTick ? time : this.getUnitTime(time);\n    state[TICK_TIME] = delay + currentTime;\n\n    if (currentTime < 0) {\n      currentTime = 0;\n    } else if (currentTime > activeDuration) {\n      currentTime = activeDuration;\n    }\n\n    state[CURRENT_TIME] = currentTime;\n    this.calculate();\n\n    if (isTick) {\n      var tickTime = state[TICK_TIME];\n\n      if (prevTime < delay && time >= 0 || state[PLAY_STATE] !== RUNNING && tickTime >= delay && !this.isEnded()) {\n        this.start(0);\n      }\n\n      if (tickTime < prevTime || this.isEnded()) {\n        this.end();\n        return;\n      }\n    }\n\n    if (this.isDelay()) {\n      return this;\n    }\n    /**\n         * This event is fired when the animator updates the time.\n         * @event Animator#timeupdate\n         * @param {Object} param The object of data to be sent to an event.\n         * @param {Number} param.currentTime The total time that the animator is running.\n         * @param {Number} param.time The iteration time during duration that the animator is running.\n         * @param {Number} param.iterationCount The iteration count that the animator is running.\n         */\n\n\n    this.trigger(TIMEUPDATE, {\n      currentTime: currentTime,\n      time: this.getIterationTime(),\n      iterationCount: state[ITERATION]\n    });\n    return this;\n  };\n  /**\n    * Get the animator's current time\n    * @return {number} current time\n    * @example\n  animator.getTime();\n    */\n\n\n  __proto.getTime = function () {\n    return this.state[CURRENT_TIME];\n  };\n\n  __proto.getUnitTime = function (time) {\n    if (isString(time)) {\n      var duration = this.getDuration() || 100;\n\n      if (time === \"from\") {\n        return 0;\n      } else if (time === \"to\") {\n        return duration;\n      }\n\n      var _a = splitUnit(time),\n          unit = _a.unit,\n          value = _a.value;\n\n      if (unit === \"%\") {\n        !this.getDuration() && this.setDuration(duration);\n        return toFixed(parseFloat(time) / 100 * duration);\n      } else if (unit === \">\") {\n        return value + THRESHOLD;\n      } else {\n        return value;\n      }\n    } else {\n      return toFixed(time);\n    }\n  };\n  /**\n     * Check if the current state of animator is delayed.\n     * @return {boolean} check delay state\n     */\n\n\n  __proto.isDelay = function () {\n    var state = this.state;\n    var delay = state[DELAY];\n    var tickTime = state[TICK_TIME];\n    return delay > 0 && tickTime < delay;\n  };\n\n  __proto.setIteration = function (iterationCount) {\n    var state = this.state;\n    var passIterationCount = Math.floor(iterationCount);\n    var maxIterationCount = state[ITERATION_COUNT] === INFINITE ? Infinity : state[ITERATION_COUNT];\n\n    if (state[ITERATION] < passIterationCount && passIterationCount < maxIterationCount) {\n      /**\n            * The event is fired when an iteration of an animation ends.\n            * @event Animator#iteration\n            * @param {Object} param The object of data to be sent to an event.\n            * @param {Number} param.currentTime The total time that the animator is running.\n            * @param {Number} param.iterationCount The iteration count that the animator is running.\n            */\n      this.trigger(\"iteration\", {\n        currentTime: state[CURRENT_TIME],\n        iterationCount: passIterationCount\n      });\n    }\n\n    state[ITERATION] = iterationCount;\n    return this;\n  };\n\n  __proto.calculate = function () {\n    var state = this.state;\n    var iterationCount = state[ITERATION_COUNT];\n    var fillMode = state[FILL_MODE];\n    var direction = state[DIRECTION];\n    var duration = this.getDuration();\n    var time = this.getTime();\n    var iteration = duration === 0 ? 0 : time / duration;\n    var currentIterationTime = duration ? time % duration : 0;\n\n    if (!duration) {\n      this.setIterationTime(0);\n      return this;\n    }\n\n    this.setIteration(iteration); // direction : normal, reverse, alternate, alternate-reverse\n    // fillMode : forwards, backwards, both, none\n\n    var isReverse = isDirectionReverse(iteration, iterationCount, direction);\n    var isFiniteDuration = isFinite(duration);\n\n    if (isFiniteDuration && isReverse) {\n      currentIterationTime = duration - currentIterationTime;\n    }\n\n    if (isFiniteDuration && iterationCount !== INFINITE) {\n      var isForwards = fillMode === \"both\" || fillMode === \"forwards\"; // fill forwards\n\n      if (iteration >= iterationCount) {\n        currentIterationTime = duration * (isForwards ? iterationCount % 1 || 1 : 0);\n        isReverse && (currentIterationTime = duration - currentIterationTime);\n      }\n    }\n\n    this.setIterationTime(currentIterationTime);\n    return this;\n  };\n\n  Animator = __decorate([GetterSetter(getters, setters, \"state\")], Animator);\n  return Animator;\n}(EventTrigger);\n\nfunction toInnerProperties(obj) {\n  if (!obj) {\n    return \"\";\n  }\n\n  var arrObj = [];\n\n  for (var name in obj) {\n    arrObj.push(name.replace(/\\d/g, \"\") + \"(\" + obj[name] + \")\");\n  }\n\n  return arrObj.join(\" \");\n}\n/* eslint-disable */\n\n\nfunction clone(target, toValue) {\n  if (toValue === void 0) {\n    toValue = false;\n  }\n\n  return merge({}, target, toValue);\n}\n\nfunction merge(to, from, toValue) {\n  if (toValue === void 0) {\n    toValue = false;\n  }\n\n  for (var name in from) {\n    var value = from[name];\n    var type = getType(value);\n\n    if (type === PROPERTY) {\n      to[name] = toValue ? value.toValue() : value.clone();\n    } else if (type === FUNCTION) {\n      to[name] = toValue ? getValue([name], value) : value;\n    } else if (type === ARRAY) {\n      to[name] = value.slice();\n    } else if (type === OBJECT) {\n      if (isObject(to[name]) && !isPropertyObject(to[name])) {\n        merge(to[name], value, toValue);\n      } else {\n        to[name] = clone(value, toValue);\n      }\n    } else {\n      to[name] = from[name];\n    }\n  }\n\n  return to;\n}\n/* eslint-enable */\n\n\nfunction getPropertyName(args) {\n  return args[0] in ALIAS ? ALIAS[args[0]] : args;\n}\n\nfunction getValue(names, value) {\n  var type = getType(value);\n\n  if (type === PROPERTY) {\n    return value.toValue();\n  } else if (type === FUNCTION) {\n    if (names[0] !== TIMING_FUNCTION) {\n      return getValue(names, value());\n    }\n  } else if (type === OBJECT) {\n    return clone(value, true);\n  }\n\n  return value;\n}\n/**\n* Animation's Frame\n*/\n\n\nvar Frame =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param - properties\n   * @example\n  const frame = new Scene.Frame({\n    display: \"none\"\n    transform: {\n        translate: \"50px\",\n        scale: \"5, 5\",\n    }\n  });\n   */\n  function Frame(properties) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    this.properties = {};\n    this.set(properties);\n  }\n  /**\n    * get property value\n    * @param {...Number|String|PropertyObject} args - property name or value\n    * @example\n    frame.get(\"display\") // => \"none\", \"block\", ....\n    frame.get(\"transform\", \"translate\") // => \"10px,10px\"\n    */\n\n\n  var __proto = Frame.prototype;\n\n  __proto.get = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var value = this.raw.apply(this, args);\n    return getValue(getPropertyName(args), value);\n  };\n\n  __proto.raw = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return getValueByNames(getPropertyName(args), this.properties);\n  };\n  /**\n    * remove property value\n    * @param {...String} args - property name\n    * @return {Frame} An instance itself\n    * @example\n    frame.remove(\"display\")\n    */\n\n\n  __proto.remove = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var params = getPropertyName(args);\n    var length = params.length;\n\n    if (!length) {\n      return this;\n    }\n\n    var value = getValueByNames(params, this.properties, length - 1);\n\n    if (isObject(value)) {\n      delete value[params[length - 1]];\n    }\n\n    return this;\n  };\n  /**\n    * set property\n    * @param {...Number|String|PropertyObject} args - property names or values\n    * @return {Frame} An instance itself\n    * @example\n  // one parameter\n  frame.set({\n    display: \"none\",\n    transform: {\n        translate: \"10px, 10px\",\n        scale: \"1\",\n    },\n    filter: {\n        brightness: \"50%\",\n        grayscale: \"100%\"\n    }\n  });\n  // two parameters\n  frame.set(\"transform\", {\n    translate: \"10px, 10px\",\n    scale: \"1\",\n  });\n  // three parameters\n  frame.set(\"transform\", \"translate\", \"50px\");\n  */\n\n\n  __proto.set = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var self = this;\n    var length = args.length;\n    var params = args.slice(0, -1);\n    var value = args[length - 1];\n\n    if (params[0] in ALIAS) {\n      self._set(ALIAS[params[0]], value);\n    } else if (length === 2 && isArray(params[0])) {\n      self._set(params[0], value);\n    } else if (isArray(value)) {\n      self._set(params, value);\n    } else if (isPropertyObject(value)) {\n      if (isRole(params)) {\n        self.set.apply(self, params.concat([toObject(value)]));\n      } else {\n        self._set(params, value);\n      }\n    } else if (isObject(value)) {\n      for (var name in value) {\n        self.set.apply(self, params.concat([name, value[name]]));\n      }\n    } else if (isString(value)) {\n      if (isRole(params, true)) {\n        if (isFixed(params) || !isRole(params)) {\n          this._set(params, value);\n        } else {\n          var obj = toPropertyObject(value);\n\n          if (isObject(obj)) {\n            self.set.apply(self, params.concat([obj]));\n          }\n        }\n\n        return this;\n      } else {\n        var _a = splitStyle(value),\n            styles = _a.styles,\n            stylesLength = _a.length;\n\n        for (var name in styles) {\n          self.set.apply(self, params.concat([name, styles[name]]));\n        }\n\n        if (stylesLength) {\n          return this;\n        }\n      }\n\n      self._set(params, value);\n    } else {\n      self._set(params, value);\n    }\n\n    return self;\n  };\n  /**\n    * check that has property.\n    * @param {...String} args - property name\n    * @example\n    frame.has(\"property\", \"display\") // => true or false\n    */\n\n\n  __proto.has = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var params = getPropertyName(args);\n    var length = params.length;\n\n    if (!length) {\n      return false;\n    }\n\n    return !isUndefined(getValueByNames(params, this.properties, length));\n  };\n  /**\n    * clone frame.\n    * @return {Frame} An instance of clone\n    * @example\n    frame.clone();\n    */\n\n\n  __proto.clone = function () {\n    var frame = new Frame();\n    return frame.merge(this);\n  };\n  /**\n    * merge one frame to other frame.\n    * @param - target frame.\n    * @return {Frame} An instance itself\n    * @example\n    frame.merge(frame2);\n    */\n\n\n  __proto.merge = function (frame) {\n    var properties = this.properties;\n    var frameProperties = frame.properties;\n\n    if (!frameProperties) {\n      return this;\n    }\n\n    merge(properties, frameProperties);\n    return this;\n  };\n  /**\n    * Specifies an css object that coverted the frame.\n    * @return {object} cssObject\n    */\n\n\n  __proto.toCSSObject = function () {\n    var properties = this.get();\n    var cssObject = {};\n\n    for (var name in properties) {\n      if (isRole([name], true)) {\n        continue;\n      }\n\n      var value = properties[name];\n\n      if (name === TIMING_FUNCTION) {\n        cssObject[TIMING_FUNCTION.replace(\"animation\", ANIMATION)] = (isString(value) ? value : value[EASING_NAME]) || \"initial\";\n        continue;\n      }\n\n      cssObject[name] = value;\n    }\n\n    var transform = toInnerProperties(properties[TRANSFORM_NAME]);\n    var filter = toInnerProperties(properties.filter);\n    TRANSFORM && transform && (cssObject[TRANSFORM] = transform);\n    FILTER && filter && (cssObject[FILTER] = filter);\n    return cssObject;\n  };\n  /**\n    * Specifies an css text that coverted the frame.\n    * @return {string} cssText\n    */\n\n\n  __proto.toCSS = function () {\n    var cssObject = this.toCSSObject();\n    var cssArray = [];\n\n    for (var name in cssObject) {\n      cssArray.push(name + \":\" + cssObject[name] + \";\");\n    }\n\n    return cssArray.join(\"\");\n  };\n\n  __proto._set = function (args, value) {\n    var properties = this.properties;\n    var length = args.length;\n\n    for (var i = 0; i < length - 1; ++i) {\n      var name = args[i];\n      !(name in properties) && (properties[name] = {});\n      properties = properties[name];\n    }\n\n    if (!length) {\n      return;\n    }\n\n    properties[args[length - 1]] = isString(value) ? toPropertyObject(value) : value;\n  };\n\n  return Frame;\n}();\n\nfunction dotArray(a1, a2, b1, b2) {\n  var length = a2.length;\n  return a1.map(function (v1, i) {\n    if (i >= length) {\n      return v1;\n    } else {\n      return dot(v1, a2[i], b1, b2);\n    }\n  });\n}\n\nfunction dotColor(color1, color2, b1, b2) {\n  // convert array to PropertyObject(type=color)\n  var value1 = color1.value;\n  var value2 = color2.value; // If the model name is not same, the inner product is impossible.\n\n  var model1 = color1.model;\n  var model2 = color2.model;\n\n  if (model1 !== model2) {\n    // It is recognized as a string.\n    return dot(color1.toValue(), color2.toValue(), b1, b2);\n  }\n\n  if (value1.length === 3) {\n    value1[3] = 1;\n  }\n\n  if (value2.length === 3) {\n    value2[3] = 1;\n  }\n\n  var v = dotArray(value1, value2, b1, b2);\n  var colorModel = model1;\n\n  for (var i = 0; i < 3; ++i) {\n    v[i] = parseInt(v[i], 10);\n  }\n\n  var object = new PropertyObject(v, {\n    type: \"color\",\n    model: colorModel,\n    prefix: colorModel + \"(\",\n    suffix: \")\"\n  });\n  return object;\n}\n\nfunction dotObject(a1, a2, b1, b2) {\n  var a1Type = a1.type;\n\n  if (a1Type === \"color\") {\n    return dotColor(a1, a2, b1, b2);\n  }\n\n  var value1 = a1.value;\n  var value2 = a2.value;\n  var arr = dotArray(value1, value2, b1, b2);\n  return new PropertyObject(arr, {\n    type: a1Type,\n    separator: a1.separator || a2.separator,\n    prefix: a1.prefix || a2.prefix,\n    suffix: a1.suffix || a2.suffix,\n    model: a1.model || a2.model\n  });\n}\n/**\n* The dot product of a1 and a2 for the b1 and b2.\n* @memberof Dot\n* @function dot\n* @param {String|Number|PropertyObject} a1 value1\n* @param {String|Number|PropertyObject} a2 value2\n* @param {Number} b1 b1 ratio\n* @param {Number} b2 b2 ratio\n* @return {String} Not Array, Not Separator, Only Number & Unit\n* @return {PropertyObject} Array with Separator.\n* @example\ndot(1, 3, 0.3, 0.7);\n// => 1.6\n*/\n\n\nfunction dot(a1, a2, b1, b2) {\n  if (b2 === 0) {\n    return a2;\n  } else if (b1 === 0 || b1 + b2 === 0) {\n    // prevent division by zero.\n    return a1;\n  } // dot Object\n\n\n  var type1 = getType(a1);\n  var type2 = getType(a2);\n  var isFunction1 = type1 === FUNCTION;\n  var isFunction2 = type2 === FUNCTION;\n\n  if (isFunction1 || isFunction2) {\n    return function () {\n      return dot(isFunction1 ? toPropertyObject(a1()) : a1, isFunction2 ? toPropertyObject(a2()) : a2, b1, b2);\n    };\n  } else if (type1 === type2) {\n    if (type1 === PROPERTY) {\n      return dotObject(a1, a2, b1, b2);\n    } else if (type1 === ARRAY) {\n      return dotArray(a1, a2, b1, b2);\n    } else if (type1 !== \"value\") {\n      return a1;\n    }\n  } else {\n    return a1;\n  }\n\n  var v1 = splitUnit(\"\" + a1);\n  var v2 = splitUnit(\"\" + a2);\n  var v; // 숫자가 아닐경우 첫번째 값을 반환 b2가 0일경우 두번째 값을 반환\n\n  if (isNaN(v1.value) || isNaN(v2.value)) {\n    return a1;\n  } else {\n    v = dotNumber(v1.value, v2.value, b1, b2);\n  }\n\n  var prefix = v1.prefix || v2.prefix;\n  var unit = v1.unit || v2.unit;\n\n  if (!prefix && !unit) {\n    return v;\n  }\n\n  return prefix + v + unit;\n}\nfunction dotNumber(a1, a2, b1, b2) {\n  return (a1 * b2 + a2 * b1) / (b1 + b2);\n}\nfunction dotValue(time, prevTime, nextTime, prevValue, nextValue, easing) {\n  if (time === prevTime) {\n    return prevValue;\n  } else if (time === nextTime) {\n    return nextValue;\n  } else if (!easing) {\n    return dot(prevValue, nextValue, time - prevTime, nextTime - time);\n  }\n\n  var ratio = easing((time - prevTime) / (nextTime - prevTime));\n  var value = dot(prevValue, nextValue, ratio, 1 - ratio);\n  return value;\n}\n\nfunction getNearTimeIndex(times, time) {\n  var length = times.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (times[i] === time) {\n      return [i, i];\n    } else if (times[i] > time) {\n      return [i > 0 ? i - 1 : 0, i];\n    }\n  }\n\n  return [length - 1, length - 1];\n}\n\nfunction makeAnimationProperties(properties) {\n  var cssArray = [];\n\n  for (var name in properties) {\n    cssArray.push(ANIMATION + \"-\" + decamelize(name) + \":\" + properties[name] + \";\");\n  }\n\n  return cssArray.join(\"\");\n}\n\nfunction isPureObject(obj) {\n  return isObject(obj) && obj.constructor === Object;\n}\n\nfunction getNames(names, stack) {\n  var arr = [];\n\n  if (isPureObject(names)) {\n    for (var name in names) {\n      stack.push(name);\n      arr = arr.concat(getNames(names[name], stack));\n      stack.pop();\n    }\n  } else {\n    arr.push(stack.slice());\n  }\n\n  return arr;\n}\n\nfunction updateFrame(names, properties) {\n  for (var name in properties) {\n    var value = properties[name];\n\n    if (!isPureObject(value)) {\n      names[name] = true;\n      continue;\n    }\n\n    if (!isObject(names[name])) {\n      names[name] = {};\n    }\n\n    updateFrame(names[name], properties[name]);\n  }\n\n  return names;\n}\n\nfunction addTime(times, time) {\n  var length = times.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (time < times[i]) {\n      times.splice(i, 0, time);\n      return;\n    }\n  }\n\n  times[length] = time;\n}\n\nfunction addEntry(entries, time, keytime) {\n  var prevEntry = entries[entries.length - 1];\n  (!prevEntry || prevEntry[0] !== time || prevEntry[1] !== keytime) && entries.push([toFixed(time), toFixed(keytime)]);\n}\n\nfunction getEntries(times, states) {\n  var entries = times.map(function (time) {\n    return [time, time];\n  });\n  var nextEntries = [];\n  states.forEach(function (state) {\n    var iterationCount = state[ITERATION_COUNT];\n    var delay = state[DELAY];\n    var playSpeed = state[PLAY_SPEED];\n    var direction = state[DIRECTION];\n    var intCount = Math.ceil(iterationCount);\n    var currentDuration = entries[entries.length - 1][0];\n    var length = entries.length;\n    var lastTime = currentDuration * iterationCount;\n\n    for (var i = 0; i < intCount; ++i) {\n      var isReverse = direction === REVERSE || direction === ALTERNATE && i % 2 || direction === ALTERNATE_REVERSE && !(i % 2);\n\n      for (var j = 0; j < length; ++j) {\n        var entry = entries[isReverse ? length - j - 1 : j];\n        var time = entry[1];\n        var currentTime = currentDuration * i + (isReverse ? currentDuration - entry[0] : entry[0]);\n        var prevEntry = entries[isReverse ? length - j : j - 1];\n\n        if (currentTime > lastTime) {\n          if (j !== 0) {\n            var prevTime = currentDuration * i + (isReverse ? currentDuration - prevEntry[0] : prevEntry[0]);\n            var divideTime = dotNumber(prevEntry[1], time, lastTime - prevTime, currentTime - lastTime);\n            addEntry(nextEntries, (delay + currentDuration * iterationCount) / playSpeed, divideTime);\n          }\n\n          break;\n        } else if (currentTime === lastTime && nextEntries[nextEntries.length - 1][0] === lastTime + delay) {\n          break;\n        }\n\n        addEntry(nextEntries, (delay + currentTime) / playSpeed, time);\n      }\n    } // delay time\n\n\n    delay && nextEntries.unshift([0, nextEntries[0][1]]);\n    entries = nextEntries;\n    nextEntries = [];\n  });\n  return entries;\n}\n/**\n* manage Frame Keyframes and play keyframes.\n* @extends Animator\n* @example\nconst item = new SceneItem({\n    0: {\n        display: \"none\",\n    },\n    1: {\n        display: \"block\",\n        opacity: 0,\n    },\n    2: {\n        opacity: 1,\n    }\n});\n*/\n\nvar SceneItem =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(SceneItem, _super);\n  /**\n    * @param - properties\n    * @param - options\n    * @example\n    const item = new SceneItem({\n        0: {\n            display: \"none\",\n        },\n        1: {\n            display: \"block\",\n            opacity: 0,\n        },\n        2: {\n            opacity: 1,\n        }\n    });\n     */\n\n\n  function SceneItem(properties, options) {\n    var _this = _super.call(this) || this;\n\n    _this.times = [];\n    _this.items = {};\n    _this.names = {};\n    _this.elements = [];\n    _this.needUpdate = true;\n\n    _this.load(properties, options);\n\n    return _this;\n  }\n\n  var __proto = SceneItem.prototype;\n\n  __proto.getDuration = function () {\n    var times = this.times;\n    var length = times.length;\n    return (length === 0 ? 0 : times[length - 1]) || this.state[DURATION];\n  };\n  /**\n    * get size of list\n    * @return {Number} length of list\n    */\n\n\n  __proto.size = function () {\n    return this.times.length;\n  };\n\n  __proto.setDuration = function (duration) {\n    if (!duration) {\n      return this;\n    }\n\n    var originalDuration = this.getDuration();\n\n    if (originalDuration > 0) {\n      var ratio_1 = duration / originalDuration;\n\n      var _a = this,\n          times = _a.times,\n          items_1 = _a.items;\n\n      var obj_1 = {};\n      this.times = times.map(function (time) {\n        var time2 = toFixed(time * ratio_1);\n        obj_1[time2] = items_1[time];\n        return time2;\n      });\n      this.items = obj_1;\n    } else {\n      this.newFrame(duration);\n    }\n\n    return this;\n  };\n\n  __proto.setId = function (id) {\n    var state = this.state;\n    state.id = id || makeId(!!length);\n    var elements = this.elements;\n\n    if (elements.length && !state[SELECTOR]) {\n      var sceneId_1 = toId(this.getId());\n      state[SELECTOR] = \"[\" + DATA_SCENE_ID + \"=\\\"\" + sceneId_1 + \"\\\"]\";\n      elements.forEach(function (element) {\n        element.setAttribute(DATA_SCENE_ID, sceneId_1);\n      });\n    }\n\n    return this;\n  };\n  /**\n    * Set properties to the sceneItem at that time\n    * @param {Number} time - time\n    * @param {...String|Object} [properties] - property names or values\n    * @return {SceneItem} An instance itself\n    * @example\n  item.set(0, \"a\", \"b\") // item.getFrame(0).set(\"a\", \"b\")\n  console.log(item.get(0, \"a\")); // \"b\"\n    */\n\n\n  __proto.set = function (time) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (isArray(time)) {\n      var length = time.length;\n\n      for (var i = 0; i < length; ++i) {\n        var t = length === 1 ? 0 : this.getUnitTime(i / (length - 1) * 100 + \"%\");\n        this.set(t, time[i]);\n      }\n    } else if (isObject(time)) {\n      var _loop_1 = function (t) {\n        var value = time[t];\n        var realTime = this_1.getUnitTime(t);\n\n        if (isNaN(realTime)) {\n          getNames(value, [t]).forEach(function (names) {\n            var innerValue = getValueByNames(names.slice(1), value);\n            var arr = isArray(innerValue) ? innerValue : [getValueByNames(names, _this.target), innerValue];\n            var length = arr.length;\n\n            for (var i = 0; i < length; ++i) {\n              _this.newFrame(i / (length - 1) * 100 + \"%\").set(names, arr[i]);\n            }\n          });\n        } else {\n          this_1.set(realTime, value);\n        }\n      };\n\n      var this_1 = this;\n\n      for (var t in time) {\n        _loop_1(t);\n      }\n    } else {\n      var value = args[0];\n\n      if (value instanceof Frame) {\n        this.setFrame(time, value);\n      } else if (value instanceof SceneItem) {\n        var delay = value.getDelay();\n        var realTime = this.getUnitTime(time);\n        var frames = value.toObject(!this.hasFrame(realTime + delay), realTime);\n\n        for (var frameTime in frames) {\n          this.set(frameTime, frames[frameTime]);\n        }\n      } else if (args.length === 1 && isArray(value)) {\n        value.forEach(function (item) {\n          _this.set(time, item);\n        });\n      } else {\n        var frame = this.newFrame(time);\n        frame.set.apply(frame, args);\n      }\n    }\n\n    this.needUpdate = true;\n    return this;\n  };\n  /**\n    * Get properties of the sceneItem at that time\n    * @param {Number} time - time\n    * @param {...String|Object} args property's name or properties\n    * @return {Number|String|PropertyObejct} property value\n    * @example\n  item.get(0, \"a\"); // item.getFrame(0).get(\"a\");\n  item.get(0, \"transform\", \"translate\"); // item.getFrame(0).get(\"transform\", \"translate\");\n    */\n\n\n  __proto.get = function (time) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var frame = this.getFrame(time);\n    return frame && frame.get.apply(frame, args);\n  };\n  /**\n    * remove properties to the sceneItem at that time\n    * @param {Number} time - time\n    * @param {...String|Object} [properties] - property names or values\n    * @return {SceneItem} An instance itself\n    * @example\n  item.remove(0, \"a\");\n    */\n\n\n  __proto.remove = function (time) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (args.length) {\n      var frame = this.getFrame(time);\n      frame && frame.remove.apply(frame, args);\n    } else {\n      this.removeFrame(time);\n    }\n\n    this.needUpdate = true;\n    return this;\n  };\n  /**\n    * Append the item or object at the last time.\n    * @param - the scene item or item object\n    * @return An instance itself\n    * @example\n  item.append(new SceneItem({\n    0: {\n        opacity: 0,\n    },\n    1: {\n        opacity: 1,\n    }\n  }));\n  item.append({\n    0: {\n        opacity: 0,\n    },\n    1: {\n        opacity: 1,\n    }\n  });\n  item.set(item.getDuration(), {\n    0: {\n        opacity: 0,\n    },\n    1: {\n        opacity: 1,\n    }\n  });\n    */\n\n\n  __proto.append = function (item) {\n    this.set(this.getDuration(), item);\n    return this;\n  };\n  /**\n    * Push the front frames for the time and prepend the scene item or item object.\n    * @param - the scene item or item object\n    * @return An instance itself\n    */\n\n\n  __proto.prepend = function (item) {\n    if (item instanceof SceneItem) {\n      var unshiftTime = item.getDuration() + item.getDelay();\n      var firstFrame = this.getFrame(0); // remove first frame\n\n      this.removeFrame(0);\n      this.unshift(unshiftTime);\n      this.set(0, item);\n      this.set(unshiftTime + THRESHOLD, firstFrame);\n    } else {\n      this.prepend(new SceneItem(item));\n    }\n\n    return this;\n  };\n  /**\n  * Push out the amount of time.\n  * @param - time to push\n   * @return {}\n   * @example\n  item.get(0); // frame 0\n  item.unshift(3);\n  item.get(3) // frame 0\n   */\n\n\n  __proto.unshift = function (time) {\n    var _a = this,\n        times = _a.times,\n        items = _a.items;\n\n    var obj = {};\n    this.times = times.map(function (t) {\n      var time2 = toFixed(time + t);\n      obj[time2] = items[t];\n      return time2;\n    });\n    this.items = obj;\n  };\n  /**\n   * Get the frames in the item in object form.\n   * @return {}\n   * @example\n  item.toObject();\n  // {0: {display: \"none\"}, 1: {display: \"block\"}}\n   */\n\n\n  __proto.toObject = function (isStartZero, startTime) {\n    if (isStartZero === void 0) {\n      isStartZero = true;\n    }\n\n    if (startTime === void 0) {\n      startTime = 0;\n    }\n\n    var obj = {};\n    var delay = this.getDelay();\n    this.forEach(function (frame, time) {\n      obj[(!time && !isStartZero ? THRESHOLD : 0) + delay + startTime + time] = frame.clone();\n    });\n    return obj;\n  };\n  /**\n   * Specifies an element to synchronize items' keyframes.\n   * @param {string} selectors - Selectors to find elements in items.\n   * @return {SceneItem} An instance itself\n   * @example\n  item.setSelector(\"#id.class\");\n   */\n\n\n  __proto.setSelector = function (target) {\n    this.setElement(target);\n  };\n  /**\n    * Specifies an element to synchronize item's keyframes.\n  * @param - elements to synchronize item's keyframes.\n  * @param - Make sure that you have peusdo.\n    * @return {SceneItem} An instance itself\n    * @example\n  item.setElement(document.querySelector(\"#id.class\"));\n  item.setElement(document.querySelectorAll(\".class\"));\n    */\n\n\n  __proto.setElement = function (target) {\n    var state = this.state;\n    var elements = [];\n\n    if (!target) {\n      return this;\n    } else if (target === true || isString(target)) {\n      var selector = target === true ? \"\" + state.id : target;\n      var matches = /([\\s\\S]+)(:+[a-zA-Z]+)$/g.exec(selector);\n      elements = toArray($(matches ? matches[1] : selector, true));\n      state[SELECTOR] = selector;\n    } else {\n      elements = target instanceof Element ? [target] : toArray(target);\n    }\n\n    if (!elements.length) {\n      return this;\n    }\n\n    this.elements = elements;\n    this.setId(this.getId());\n    this.target = elements[0].style;\n\n    this.targetFunc = function (frame) {\n      var attributes = frame.get(\"attribute\");\n\n      if (attributes) {\n        var _loop_2 = function (name) {\n          elements.forEach(function (el) {\n            el.setAttribute(name, attributes[name]);\n          });\n        };\n\n        for (var name in attributes) {\n          _loop_2(name);\n        }\n      }\n\n      var cssText = frame.toCSS();\n\n      if (state.cssText !== cssText) {\n        state.cssText = cssText;\n        elements.forEach(function (el) {\n          el.style.cssText += cssText;\n        });\n        return frame;\n      }\n    };\n\n    return this;\n  };\n\n  __proto.setTarget = function (target) {\n    this.target = target;\n\n    this.targetFunc = function (frame) {\n      var obj = frame.get();\n\n      for (var name in obj) {\n        target[name] = obj[name];\n      }\n    };\n\n    return this;\n  };\n  /**\n    * add css styles of items's element to the frame at that time.\n    * @param {Array} properties - elements to synchronize item's keyframes.\n    * @return {SceneItem} An instance itself\n    * @example\n  item.setElement(document.querySelector(\"#id.class\"));\n  item.setCSS(0, [\"opacity\"]);\n  item.setCSS(0, [\"opacity\", \"width\", \"height\"]);\n    */\n\n\n  __proto.setCSS = function (time, properties) {\n    this.set(time, fromCSS(this.elements, properties));\n    return this;\n  };\n\n  __proto.setTime = function (time, isTick, parentEasing) {\n    _super.prototype.setTime.call(this, time, isTick);\n\n    var iterationTime = this.getIterationTime();\n    var easing = this.getEasing() || parentEasing;\n    var frame = this.getNowFrame(iterationTime, easing);\n    var currentTime = this.getTime();\n    this.temp = frame;\n    /**\n         * This event is fired when timeupdate and animate.\n         * @event SceneItem#animate\n         * @param {Number} param.currentTime The total time that the animator is running.\n         * @param {Number} param.time The iteration time during duration that the animator is running.\n         * @param {Frame} param.frame frame of that time.\n         */\n\n    this.trigger(\"animate\", {\n      frame: frame,\n      currentTime: currentTime,\n      time: iterationTime\n    });\n    this.targetFunc && this.targetFunc(frame);\n    return this;\n  };\n  /**\n    * update property names used in frames.\n    * @return {SceneItem} An instance itself\n    * @example\n  item.update();\n    */\n\n\n  __proto.update = function () {\n    var names = {};\n    this.forEach(function (frame) {\n      updateFrame(names, frame.properties);\n    });\n    this.names = names;\n    this.needUpdate = false;\n    return this;\n  };\n  /**\n    * Create and add a frame to the sceneItem at that time\n    * @param {Number} time - frame's time\n    * @return {Frame} Created frame.\n    * @example\n  item.newFrame(time);\n    */\n\n\n  __proto.newFrame = function (time) {\n    var frame = this.getFrame(time);\n\n    if (frame) {\n      return frame;\n    }\n\n    frame = new Frame();\n    this.setFrame(time, frame);\n    return frame;\n  };\n  /**\n    * Add a frame to the sceneItem at that time\n    * @param {Number} time - frame's time\n    * @return {SceneItem} An instance itself\n    * @example\n  item.setFrame(time, frame);\n    */\n\n\n  __proto.setFrame = function (time, frame) {\n    var realTime = this.getUnitTime(time);\n    this.items[realTime] = frame;\n    addTime(this.times, realTime);\n    this.needUpdate = true;\n    return this;\n  };\n  /**\n    * get sceneItem's frame at that time\n    * @param {Number} time - frame's time\n    * @return {Frame} sceneItem's frame at that time\n    * @example\n  const frame = item.getFrame(time);\n    */\n\n\n  __proto.getFrame = function (time) {\n    return this.items[this.getUnitTime(time)];\n  };\n  /**\n    * remove sceneItem's frame at that time\n    * @param - frame's time\n    * @return {SceneItem} An instance itself\n    * @example\n  item.removeFrame(time);\n    */\n\n\n  __proto.removeFrame = function (time) {\n    var realTime = this.getUnitTime(time);\n    var items = this.items;\n    var index = this.times.indexOf(realTime);\n    delete items[realTime]; // remove time\n\n    if (index > -1) {\n      this.times.splice(index, 1);\n    }\n\n    this.needUpdate = true;\n    return this;\n  };\n  /**\n    * check if the item has a frame at that time\n    * @param {Number} time - frame's time\n    * @return {Boolean} true: the item has a frame // false: not\n    * @example\n  if (item.hasFrame(10)) {\n    // has\n  } else {\n    // not\n  }\n    */\n\n\n  __proto.hasFrame = function (time) {\n    return this.getUnitTime(time) in this.items;\n  };\n  /**\n    * Check if keyframes has propery's name\n    * @param - property's time\n    * @return {boolean} true: if has property, false: not\n    * @example\n  item.hasName([\"transform\", \"translate\"]); // true or not\n    */\n\n\n  __proto.hasName = function (args) {\n    this.needUpdate && this.update();\n    return isInProperties(this.names, args, true);\n  };\n  /**\n    * merge frame of the previous time at the next time.\n  * @param - The time of the frame to merge\n  * @param - The target frame\n    * @return {SceneItem} An instance itself\n    * @example\n  // getFrame(1) contains getFrame(0)\n  item.merge(0, 1);\n    */\n\n\n  __proto.mergeFrame = function (time, frame) {\n    if (frame) {\n      var toFrame = this.newFrame(time);\n      toFrame.merge(frame);\n    }\n\n    return this;\n  };\n  /**\n    * Get frame of the current time\n    * @param {Number} time - the current time\n    * @param {function} easing - the speed curve of an animation\n    * @return {Frame} frame of the current time\n    * @example\n  let item = new SceneItem({\n    0: {\n        display: \"none\",\n    },\n    1: {\n        display: \"block\",\n        opacity: 0,\n    },\n    2: {\n        opacity: 1,\n    }\n  });\n  // opacity: 0.7; display:\"block\";\n  const frame = item.getNowFrame(1.7);\n    */\n\n\n  __proto.getNowFrame = function (time, easing, isAccurate) {\n    var _this = this;\n\n    this.needUpdate && this.update();\n    var frame = new Frame();\n\n    var _a = getNearTimeIndex(this.times, time),\n        left = _a[0],\n        right = _a[1];\n\n    var realEasing = this.getEasing() || easing;\n    var nameObject = this.names;\n\n    if (this.hasName([TIMING_FUNCTION])) {\n      var nowEasing = this.getNowValue(time, [TIMING_FUNCTION], left, right, false, 0, true);\n      isFunction(nowEasing) && (realEasing = nowEasing);\n    }\n\n    if (isAccurate) {\n      var prevFrame = this.getFrame(time);\n      var prevNames = updateFrame({}, prevFrame.properties);\n\n      for (var name in ROLES) {\n        if (name in prevNames) {\n          prevNames[name] = nameObject[name];\n        }\n      }\n\n      nameObject = prevNames;\n    }\n\n    var names = getNames(nameObject, []);\n    names.forEach(function (properties) {\n      var value = _this.getNowValue(time, properties, left, right, isAccurate, realEasing, isFixed(properties));\n\n      if (isUndefined(value)) {\n        return;\n      }\n\n      frame.set(properties, value);\n    });\n    return frame;\n  };\n\n  __proto.load = function (properties, options) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    if (options === void 0) {\n      options = properties.options;\n    }\n\n    options && this.setOptions(options);\n\n    if (isArray(properties)) {\n      this.set(properties);\n    } else if (properties.keyframes) {\n      this.set(properties.keyframes);\n    } else {\n      for (var time in properties) {\n        if (time !== \"options\") {\n          this.set((_a = {}, _a[time] = properties[time], _a));\n        }\n      }\n    }\n\n    if (options && options[DURATION]) {\n      this.setDuration(options[DURATION]);\n    }\n\n    return this;\n\n    var _a;\n  };\n  /**\n     * clone SceneItem.\n     * @return {SceneItem} An instance of clone\n     * @example\n     * item.clone();\n     */\n\n\n  __proto.clone = function () {\n    var item = new SceneItem();\n    item.setOptions(this.state);\n    this.forEach(function (frame, time) {\n      item.setFrame(time, frame.clone());\n    });\n    return item;\n  };\n  /**\n     * executes a provided function once for each scene item.\n     * @param - Function to execute for each element, taking three arguments\n     * @return {Keyframes} An instance itself\n     */\n\n\n  __proto.forEach = function (callback) {\n    var times = this.times;\n    var items = this.items;\n    times.forEach(function (time) {\n      callback(items[time], time, items);\n    });\n    return this;\n  };\n\n  __proto.setOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    _super.prototype.setOptions.call(this, options);\n\n    var id = options.id,\n        selector = options.selector,\n        elements = options.elements,\n        element = options.element,\n        target = options.target;\n    id && this.setId(id);\n\n    if (target) {\n      this.setTarget(target);\n    } else if (elements || element || selector) {\n      this.setElement(elements || element || selector);\n    }\n\n    return this;\n  };\n\n  __proto.toCSS = function (playCondition, parentDuration, states) {\n    if (playCondition === void 0) {\n      playCondition = {\n        className: START_ANIMATION\n      };\n    }\n\n    if (parentDuration === void 0) {\n      parentDuration = this.getDuration();\n    }\n\n    if (states === void 0) {\n      states = [];\n    }\n\n    var itemState = this.state;\n    var selector = itemState[SELECTOR];\n\n    if (!selector) {\n      return \"\";\n    }\n\n    var originalDuration = this.getDuration();\n    itemState[DURATION] = originalDuration;\n    states.push(itemState);\n    var reversedStates = toArray(states).reverse();\n    var id = toId(getRealId(this));\n    var superParent = states[0];\n    var infiniteIndex = findIndex(reversedStates, function (state) {\n      return state[ITERATION_COUNT] === INFINITE || !isFinite(state[DURATION]);\n    }, states.length - 1);\n    var finiteStates = reversedStates.slice(0, infiniteIndex);\n    var duration = parentDuration || finiteStates.reduce(function (prev, cur) {\n      return (cur[DELAY] + prev * cur[ITERATION_COUNT]) / cur[PLAY_SPEED];\n    }, originalDuration);\n    var delay = reversedStates.slice(infiniteIndex).reduce(function (prev, cur) {\n      return (prev + cur[DELAY]) / cur[PLAY_SPEED];\n    }, 0);\n    var easingName = find(reversedStates, function (state) {\n      return state[EASING] && state[EASING_NAME];\n    }, itemState)[EASING_NAME];\n    var iterationCount = reversedStates[infiniteIndex][ITERATION_COUNT];\n    var fillMode = superParent[FILL_MODE];\n    var direction = reversedStates[infiniteIndex][DIRECTION];\n    var cssText = makeAnimationProperties({\n      fillMode: fillMode,\n      direction: direction,\n      iterationCount: iterationCount,\n      delay: delay + \"s\",\n      name: PREFIX + \"KEYFRAMES_\" + id,\n      duration: duration / superParent[PLAY_SPEED] + \"s\",\n      timingFunction: easingName\n    });\n    var selectors = splitComma(selector).map(function (sel) {\n      var matches = /([\\s\\S]+)(:+[a-zA-Z]+)$/g.exec(sel);\n\n      if (matches) {\n        return [matches[0], matches[1]];\n      } else {\n        return [sel, \"\"];\n      }\n    });\n    var className = playCondition.className;\n    var selectorCallback = playCondition.selector;\n    var preselector = isFunction(selectorCallback) ? selectorCallback(this, selector) : selectorCallback;\n    return \"\\n    \" + (preselector || selectors.map(function (_a) {\n      var sel = _a[0],\n          peusdo = _a[1];\n      return sel + \".\" + className + peusdo;\n    })) + \" {\" + cssText + \"}\\n    \" + selectors.map(function (_a) {\n      var sel = _a[0],\n          peusdo = _a[1];\n      return sel + \".\" + PAUSE_ANIMATION + peusdo;\n    }) + \" {\" + ANIMATION + \"-play-state: paused;}\\n    @\" + KEYFRAMES + \" \" + PREFIX + \"KEYFRAMES_\" + id + \"{\" + this._toKeyframes(duration, finiteStates, direction) + \"}\";\n  };\n  /**\n   * Export the CSS of the items to the style.\n   * @param - Add a selector or className to play.\n   * @return {SceneItem} An instance itself\n   */\n\n\n  __proto.exportCSS = function (playCondition, duration, options) {\n    if (!this.elements.length) {\n      return \"\";\n    }\n\n    var css = this.toCSS(playCondition, duration, options);\n    var isParent = options && !isUndefined(options[ITERATION_COUNT]);\n    !isParent && exportCSS(getRealId(this), css);\n    return this;\n  };\n\n  __proto.pause = function () {\n    _super.prototype.pause.call(this);\n\n    isPausedCSS(this) && this.pauseCSS();\n    return this;\n  };\n\n  __proto.pauseCSS = function () {\n    this.elements.forEach(function (element) {\n      addClass(element, PAUSE_ANIMATION);\n    });\n    return this;\n  };\n\n  __proto.endCSS = function () {\n    this.elements.forEach(function (element) {\n      removeClass(element, PAUSE_ANIMATION);\n      removeClass(element, START_ANIMATION);\n    });\n    setPlayCSS(this, false);\n    return this;\n  };\n\n  __proto.end = function () {\n    isEndedCSS(this) && this.endCSS();\n\n    _super.prototype.end.call(this);\n\n    return this;\n  };\n  /**\n    * Play using the css animation and keyframes.\n    * @param - Check if you want to export css.\n    * @param [playClassName=\"startAnimation\"] - Add a class name to play.\n    * @param - The shorthand properties for six of the animation properties.\n    * @see {@link https://www.w3schools.com/cssref/css3_pr_animation.asp}\n    * @example\n  item.playCSS();\n  item.playCSS(false, \"startAnimation\", {\n    direction: \"reverse\",\n    fillMode: \"forwards\",\n  });\n    */\n\n\n  __proto.playCSS = function (isExportCSS, playClassName, properties) {\n    if (isExportCSS === void 0) {\n      isExportCSS = true;\n    }\n\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    playCSS(this, isExportCSS, playClassName, properties);\n    return this;\n  };\n\n  __proto.addPlayClass = function (isPaused, playClassName, properties) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    var elements = this.elements;\n    var length = elements.length;\n    var cssText = makeAnimationProperties(properties);\n\n    if (!length) {\n      return;\n    }\n\n    if (isPaused) {\n      elements.forEach(function (element) {\n        removeClass(element, PAUSE_ANIMATION);\n      });\n    } else {\n      elements.forEach(function (element) {\n        element.style.cssText += cssText;\n\n        if (hasClass(element, START_ANIMATION)) {\n          removeClass(element, START_ANIMATION);\n          requestAnimationFrame(function () {\n            requestAnimationFrame(function () {\n              addClass(element, START_ANIMATION);\n            });\n          });\n        } else {\n          addClass(element, START_ANIMATION);\n        }\n      });\n    }\n\n    return elements[0];\n  };\n\n  __proto.getNowValue = function (time, properties, left, right, isAccurate, easing, usePrevValue) {\n    var times = this.times;\n    var length = times.length;\n    var prevTime;\n    var nextTime;\n    var prevFrame;\n    var nextFrame;\n    var isUndefinedLeft = isUndefined(left);\n    var isUndefinedRight = isUndefined(right);\n\n    if (isUndefinedLeft || isUndefinedRight) {\n      var indicies = getNearTimeIndex(times, time);\n      isUndefinedLeft && (left = indicies[0]);\n      isUndefinedRight && (right = indicies[1]);\n    }\n\n    for (var i = left; i >= 0; --i) {\n      var frame = this.getFrame(times[i]);\n\n      if (frame.has.apply(frame, properties)) {\n        prevTime = times[i];\n        prevFrame = frame;\n        break;\n      }\n    }\n\n    var prevValue = prevFrame && prevFrame.raw.apply(prevFrame, properties);\n\n    if (isAccurate && !isRole([properties[0]])) {\n      return prevTime === time ? prevValue : undefined;\n    }\n\n    if (usePrevValue) {\n      return prevValue;\n    }\n\n    for (var i = right; i < length; ++i) {\n      var frame = this.getFrame(times[i]);\n\n      if (frame.has.apply(frame, properties)) {\n        nextTime = times[i];\n        nextFrame = frame;\n        break;\n      }\n    }\n\n    var nextValue = nextFrame && nextFrame.raw.apply(nextFrame, properties);\n\n    if (!prevFrame || isUndefined(prevValue)) {\n      return nextValue;\n    }\n\n    if (!nextFrame || isUndefined(nextValue) || prevValue === nextValue) {\n      return prevValue;\n    }\n\n    return dotValue(time, Math.max(prevTime, 0), nextTime, prevValue, nextValue, easing);\n  };\n\n  __proto._toKeyframes = function (duration, states, direction) {\n    var _this = this;\n\n    var frames = {};\n    var times = this.times.slice();\n\n    if (!times.length) {\n      return \"\";\n    }\n\n    var originalDuration = this.getDuration();\n    !this.getFrame(0) && times.unshift(0);\n    !this.getFrame(originalDuration) && times.push(originalDuration);\n    var entries = getEntries(times, states);\n    var lastEntry = entries[entries.length - 1]; // end delay time\n\n    lastEntry[0] < duration && addEntry(entries, duration, lastEntry[1]);\n    var prevTime = -1;\n    return entries.map(function (_a) {\n      var time = _a[0],\n          keytime = _a[1];\n\n      if (!frames[keytime]) {\n        frames[keytime] = (!_this.hasFrame(keytime) || keytime === 0 || keytime === originalDuration ? _this.getNowFrame(keytime) : _this.getNowFrame(keytime, 0, true)).toCSS();\n      }\n\n      var frameTime = time / duration * 100;\n\n      if (frameTime - prevTime < THRESHOLD) {\n        frameTime += THRESHOLD;\n      }\n\n      prevTime = frameTime;\n      return Math.min(frameTime, 100) + \"%{\\n                \" + (time === 0 && !isDirectionReverse(0, 1, direction) ? \"\" : frames[keytime]) + \"\\n            }\";\n    }).join(\"\");\n  };\n\n  return SceneItem;\n}(Animator);\n\n/**\n * manage sceneItems and play Scene.\n * @sort 1\n */\n\nvar Scene =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(Scene, _super);\n  /**\n  * @param - properties\n  * @param - options\n  * @example\n  const scene = new Scene({\n    item1: {\n      0: {\n        display: \"none\",\n      },\n      1: {\n        display: \"block\",\n        opacity: 0,\n      },\n      2: {\n        opacity: 1,\n      },\n    },\n    item2: {\n      2: {\n        opacity: 1,\n      },\n    }\n  });\n    */\n\n\n  function Scene(properties, options) {\n    var _this = _super.call(this) || this;\n\n    _this.items = {};\n\n    _this.load(properties, options);\n\n    return _this;\n  }\n\n  var __proto = Scene.prototype;\n\n  __proto.getDuration = function () {\n    var items = this.items;\n    var time = 0;\n\n    for (var id in items) {\n      var item = items[id];\n      time = Math.max(time, item.getTotalDuration() / item.getPlaySpeed());\n    }\n\n    return time || this.state[DURATION];\n  };\n\n  __proto.setDuration = function (duration) {\n    var items = this.items;\n    var sceneDuration = this.getDuration();\n\n    if (duration === 0 || !isFinite(sceneDuration)) {\n      return this;\n    }\n\n    if (sceneDuration === 0) {\n      for (var id in items) {\n        var item = items[id];\n        item.setDuration(duration);\n      }\n    } else {\n      var ratio = duration / sceneDuration;\n\n      for (var id in items) {\n        var item = items[id];\n        item.setDelay(item.getDelay() * ratio);\n        item.setDuration(item.getDuration() * ratio);\n      }\n    }\n\n    _super.prototype.setDuration.call(this, duration);\n\n    return this;\n  };\n  /**\n  * get item in scene by name\n  * @param - The item's name\n  * @param - If item is added as function, it can be imported via index.\n  * @return {Scene | SceneItem} item\n  * @example\n  const item = scene.getItem(\"item1\")\n  */\n\n\n  __proto.getItem = function (name, index) {\n    if (index != null) {\n      return this.items[name].getItem(index);\n    }\n\n    return this.items[name];\n  };\n  /**\n  * create item in scene\n  * @param {} name - name of item to create\n  * @param {} options - The option object of SceneItem\n  * @return {} Newly created item\n  * @example\n  const item = scene.newItem(\"item1\")\n  */\n\n\n  __proto.newItem = function (name, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (name in this.items) {\n      return;\n    }\n\n    var item = new SceneItem();\n    this.setItem(name, item);\n    item.setOptions(options);\n    return item;\n  };\n  /**\n  * remove item in scene\n  * @param - name of item to remove\n  * @return  An instance itself\n  * @example\n  const item = scene.newItem(\"item1\")\n   scene.removeItem(\"item1\");\n  */\n\n\n  __proto.removeItem = function (name) {\n    var items = this.items;\n\n    if (name in items) {\n      delete items[name];\n    }\n\n    return this;\n  };\n  /**\n  * add a sceneItem to the scene\n  * @param - name of item to create\n  * @param - sceneItem\n  * @example\n  const item = scene.newItem(\"item1\")\n  */\n\n\n  __proto.setItem = function (name, item) {\n    item.setId(name);\n    this.items[name] = item;\n    return this;\n  };\n\n  __proto.setTime = function (time, isTick, parentEasing) {\n    _super.prototype.setTime.call(this, time, isTick);\n\n    var iterationTime = this.getIterationTime();\n    var items = this.items;\n    var easing = this.getEasing() || parentEasing;\n    var frames = {};\n\n    for (var id in items) {\n      var item = items[id];\n      item.setTime(iterationTime * item.getPlaySpeed() - item.getDelay(), isTick, easing);\n      frames[item.getId()] = item.temp;\n    }\n\n    this.temp = frames;\n    /**\n         * This event is fired when timeupdate and animate.\n         * @event Scene#animate\n     * @param {object} param The object of data to be sent to an event.\n         * @param {number} param.currentTime The total time that the animator is running.\n         * @param {number} param.time The iteration time during duration that the animator is running.\n         * @param {object} param.frames frames of that time.\n     * @example\n    const scene = new Scene({\n    a: {\n    0: {\n      opacity: 0,\n    },\n    1: {\n      opacity: 1,\n    }\n    },\n    b: {\n    0: {\n      opacity: 0,\n    },\n    1: {\n      opacity: 1,\n    }\n    }\n    }).on(\"animate\", e => {\n    console.log(e);\n    // {a: Frame, b: Frame}\n    console.log(e.a.get(\"opacity\"));\n    });\n         */\n\n    this.trigger(\"animate\", {\n      frames: frames,\n      currentTime: this.getTime(),\n      time: iterationTime\n    });\n    return this;\n  };\n  /**\n   * executes a provided function once for each scene item.\n   * @param - Function to execute for each element, taking three arguments\n   * @return {Scene} An instance itself\n   */\n\n\n  __proto.forEach = function (func) {\n    var items = this.items;\n\n    for (var name in items) {\n      func(items[name], name, items);\n    }\n\n    return this;\n  };\n\n  __proto.toCSS = function (playCondition, duration, parentStates) {\n    if (duration === void 0) {\n      duration = this.getDuration();\n    }\n\n    if (parentStates === void 0) {\n      parentStates = [];\n    }\n\n    var totalDuration = !duration || !isFinite(duration) ? 0 : duration;\n    var styles = [];\n    var state = this.state;\n    state[DURATION] = this.getDuration();\n    this.forEach(function (item) {\n      styles.push(item.toCSS(playCondition, totalDuration, parentStates.concat(state)));\n    });\n    return styles.join(\"\");\n  };\n  /**\n   * Export the CSS of the items to the style.\n   * @param - Add a selector or className to play.\n   * @return {Scene} An instance itself\n   */\n\n\n  __proto.exportCSS = function (playCondition, duration, parentStates) {\n    var css = this.toCSS(playCondition, duration, parentStates);\n    (!parentStates || !parentStates.length) && exportCSS(getRealId(this), css);\n    return this;\n  };\n\n  __proto.append = function (item) {\n    item.setDelay(item.getDelay() + this.getDuration());\n    this.setItem(getRealId(item), item);\n  };\n\n  __proto.pauseCSS = function () {\n    return this.forEach(function (item) {\n      item.pauseCSS();\n    });\n  };\n\n  __proto.pause = function () {\n    _super.prototype.pause.call(this);\n\n    isPausedCSS(this) && this.pauseCSS();\n    this.forEach(function (item) {\n      item.pause();\n    });\n    return this;\n  };\n\n  __proto.endCSS = function () {\n    var items = this.items;\n\n    for (var id in items) {\n      items[id].endCSS();\n    }\n\n    setPlayCSS(this, false);\n  };\n\n  __proto.end = function () {\n    isEndedCSS(this) && this.endCSS();\n\n    _super.prototype.end.call(this);\n\n    return this;\n  };\n\n  __proto.addPlayClass = function (isPaused, playClassName, properties) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    var items = this.items;\n    var animtionElement;\n\n    for (var id in items) {\n      var el = items[id].addPlayClass(isPaused, playClassName, properties);\n      !animtionElement && (animtionElement = el);\n    }\n\n    return animtionElement;\n  };\n  /**\n  * Play using the css animation and keyframes.\n  * @param - Check if you want to export css.\n  * @param [playClassName=\"startAnimation\"] - Add a class name to play.\n  * @param - The shorthand properties for six of the animation properties.\n  * @return {Scene} An instance itself\n  * @see {@link https://www.w3schools.com/cssref/css3_pr_animation.asp}\n  * @example\n  scene.playCSS();\n  scene.playCSS(false, {\n  direction: \"reverse\",\n  fillMode: \"forwards\",\n  });\n  */\n\n\n  __proto.playCSS = function (isExportCSS, playClassName, properties) {\n    if (isExportCSS === void 0) {\n      isExportCSS = true;\n    }\n\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    playCSS(this, isExportCSS, playClassName, properties);\n    return this;\n  };\n\n  __proto.set = function (properties) {\n    this.load(properties);\n    return this;\n  };\n\n  __proto.load = function (properties, options) {\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    if (options === void 0) {\n      options = properties.options;\n    }\n\n    if (!properties) {\n      return this;\n    }\n\n    var isSelector = options && options[SELECTOR] || this.state[SELECTOR];\n\n    for (var name in properties) {\n      if (name === \"options\") {\n        continue;\n      }\n\n      var object = properties[name];\n      var item = void 0;\n\n      if (object instanceof Scene || object instanceof SceneItem) {\n        this.setItem(name, object);\n        item = object;\n      } else if (isFunction(object) && isSelector) {\n        var elements = IS_WINDOW ? $(name, true) : [];\n        var length = elements.length;\n        var scene = new Scene();\n\n        for (var i = 0; i < length; ++i) {\n          var id = makeId();\n          scene.newItem(\"\" + i, {\n            id: id,\n            selector: \"[\" + DATA_SCENE_ID + \"=\\\"\" + id + \"\\\"]\",\n            elements: elements[i]\n          }).load(object(i, elements[i]));\n        }\n\n        this.setItem(name, scene);\n        continue;\n      } else {\n        item = this.newItem(name);\n        item.load(object);\n      }\n\n      isSelector && item.setSelector(name);\n    }\n\n    this.setOptions(options);\n  };\n\n  __proto.setOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    _super.prototype.setOptions.call(this, options);\n\n    if (options.selector) {\n      this.state[SELECTOR] = true;\n    }\n\n    return this;\n  };\n\n  __proto.setSelector = function (target) {\n    var state = this.state;\n    var isSelector = target || state[SELECTOR];\n    state[SELECTOR] = target;\n    this.forEach(function (item, name) {\n      item.setSelector(isSelector ? name : false);\n    });\n  };\n\n  __proto.start = function (delay) {\n    _super.prototype.start.call(this, delay);\n\n    this.forEach(function (item) {\n      item.start(delay);\n    });\n  };\n  /**\n  * version info\n  * @type {string}\n  * @example\n  * Scene.VERSION // 1.0.0-rc8\n  */\n\n\n  Scene.VERSION = \"1.0.0-rc8\";\n  return Scene;\n}(Animator);\n\n/**\n * @namespace presets\n */\n\nfunction animate(properties, options) {\n  return new Scene(properties, options).play();\n}\nfunction animateItem(properties, options) {\n  return new SceneItem(properties, options).play();\n}\n/**\n * Use the property to create an effect.\n * @memberof presets\n * @private\n * @param - property to set effect\n * @param - values of 100%\n * @example\n// import {set, blink} from \"scenejs\";\n// set(\"opacity\", [0, 1, 0], {duration: 2});\nScene.set(\"opacity\", [0, 1, 0], {duration: 2});\n\n// Same\nScene.blink({duration: 2});\n\n// Same\nnew SceneItem({\n    \"0%\": {\n        opacity: 0,\n    },\n    \"50%\": {\n        opacity: 1,\n    }\n    \"100%\": {\n        opacity: 0,\n    }\n}, {\n    duration: 2,\n});\n */\n\nfunction set(property, values, options) {\n  var item = new SceneItem({}, options);\n  var length = values.length;\n\n  for (var i = 0; i < length; ++i) {\n    item.set(i / (length - 1) * 100 + \"%\", property, values[i]);\n  }\n\n  return item;\n}\n/**\n * Make a zoom in effect.\n * @memberof presets\n * @param {AnimatorOptions} options\n * @param {number} [options.from = 0] start zoom\n * @param {number}[options.to = 1] end zoom\n * @param {number} options.duration animation's duration\n * @example\n// import {set, zoomIn} from \"scenejs\";\n// zoomIn({duration: 2});\nScene.zoomIn({duration: 2});\n// Same\nnew SceneItem({\n    \"0%\": {\n        \"transform\": \"scale(0)\",\n    },\n    \"100%\": {\n        \"transform\": \"scale(1)\",\n    }\n}, {\n    duration: 2,\n});\n */\n\n\nfunction zoomIn(_a) {\n  var _b = _a.from,\n      from = _b === void 0 ? 0 : _b,\n      _c = _a.to,\n      to = _c === void 0 ? 1 : _c;\n  return set([TRANSFORM_NAME, \"scale\"], [from, to], arguments[0]);\n}\n/**\n * Make a zoom out effect.\n * @memberof presets\n * @param {AnimatorOptions} options\n * @param {number} [options.from = 1] start zoom\n * @param {number}[options.to = 0] end zoom\n * @param {number} options.duration animation's duration\n * @example\n// import {zoomOut} from \"scenejs\";\n// zoomOut({duration: 2});\nScene.zoomOut({duration: 2});\n// Same\nnew SceneItem({\n    \"0%\": {\n        \"transform\": \"scale(1)\",\n    },\n    \"100%\": {\n        \"transform\": \"scale(0)\",\n    }\n}, {\n    duration: 2,\n});\n */\n\nfunction zoomOut(_a) {\n  var _b = _a.from,\n      from = _b === void 0 ? 1 : _b,\n      _c = _a.to,\n      to = _c === void 0 ? 0 : _c;\n  return set([TRANSFORM_NAME, \"scale\"], [from, to], arguments[0]);\n}\n/**\n * Make a wipe in effect.\n * @memberof presets\n * @param {AnimatorOptions} options\n * @param {string|string[]} [options.property = \"left\"] position property\n * @param {number|string} [options.from = \"-100%\"] start position\n * @param {number|string}[options.to = \"0%\"] end position\n * @param {number} options.duration animation's duration\n * @example\n// import {wipeIn} from \"scenejs\";\n// wipeIn({property: \"left\", duration: 2});\nScene.wipeIn({property: \"left\", duration: 2});\n// Same\nnew SceneItem({\n    \"0%\": {\n        \"left\": \"-100%\",\n    },\n    \"100%\": {\n        \"left\": \"0%\",\n    }\n}, {\n    duration: 2,\n});\n */\n\nfunction wipeIn(_a) {\n  var _b = _a.from,\n      from = _b === void 0 ? \"-100%\" : _b,\n      _c = _a.to,\n      to = _c === void 0 ? \"0%\" : _c,\n      _d = _a.property,\n      property = _d === void 0 ? \"left\" : _d;\n  return set(property, [from, to], arguments[0]);\n}\n/**\n * Make a wipe out effect.\n * @memberof presets\n * @param {AnimatorOptions} options\n * @param {string|string[]} [options.property = \"left\"] position property\n * @param {number|string} [options.from = \"0%\"] start position\n * @param {number|string}[options.to = \"100%\"] end position\n * @param {number} options.duration animation's duration\n * @example\n// import {wipeOut} from \"scenejs\";\n// wipeOut({property: \"left\", duration: 2});\nScene.wipeOut({property: \"left\", duration: 2});\n// Same\nnew SceneItem({\n    \"0%\": {\n        \"left\": \"0%\",\n    },\n    \"100%\": {\n        \"left\": \"100%\",\n    }\n}, {\n    duration: 2,\n});\n */\n\nfunction wipeOut(_a) {\n  var _b = _a.from,\n      from = _b === void 0 ? \"0%\" : _b,\n      _c = _a.to,\n      to = _c === void 0 ? \"100%\" : _c,\n      _d = _a.property,\n      property = _d === void 0 ? \"left\" : _d;\n  return set(property, [from, to], arguments[0]);\n}\n/**\n * Use the property to create an effect.\n * @memberof presets\n * @param {Scene.SceneItem} item1 - Item that end effect\n * @param {Scene.SceneItem} item2 - Item that start effect\n * @param {AnimatorOptions} options\n * @param {object} options.from The starting properties of item1 and end properties of item2\n * @param {object} options.to The starting properties of item2 and end properties of item1\n * @param {number} options.duration animation's duration\n * @param {number} [options.time] start time of item1 <br/> <strong>default: item1.getDuration() - duration</strong>\n * @example\n// import {transition} from \"scenejs\";\ntransition(item1, item2, {\n    from: {\n        opacity: 1,\n    },\n    to: {\n        opacity: 0,\n    },\n    duration: 0.1,\n});\n\n// Same\nitem1.set({\n    [item1.getDuration() - 0.1]: {\n        opacity: 1,\n    },\n    [item1.getDuration()]: {\n        opacity: 0,\n    }\n});\nitem2.set({\n    0: {\n        opacity: 0,\n    },\n    0.1: {\n        opacity: 1,\n    }\n});\n */\n\nfunction transition(item1, item2, _a) {\n  var from = _a.from,\n      to = _a.to,\n      _b = _a.duration,\n      duration = _b === void 0 ? item1.getDuration() : _b,\n      _c = _a.time,\n      time = _c === void 0 ? Math.max(item1.getDuration() - duration, 0) : _c;\n  item1.set((_d = {}, _d[time] = to, _d[time + duration] = from, _d));\n  item2.set((_e = {\n    0: from\n  }, _e[duration] = to, _e));\n\n  var _d, _e;\n}\n/**\n * Make a fade in effect.\n * @memberof presets\n * @param {AnimatorState} options\n * @param {number} [options.from = 0] start opacity\n * @param {number}[options.to = 1] end opacity\n * @param {number} options.duration animation's duration\n * @example\n// import {fadeIn} from \"scenejs\";\n// fadeIn({duration: 2});\nScene.fadeIn({duration: 2});\n// Same\nnew SceneItem({\n    \"0%\": {\n        opacity: 0,\n    },\n    \"100%\": {\n        opacity: 1,\n    }\n}, {\n    duration: 2,\n});\n */\n\nfunction fadeIn(_a) {\n  var _b = _a.from,\n      from = _b === void 0 ? 0 : _b,\n      _c = _a.to,\n      to = _c === void 0 ? 1 : _c;\n  return set(\"opacity\", [from, to], arguments[0]);\n}\n/**\n * Make a fade out effect.\n * @memberof presets\n * @param {AnimatorState} options\n * @param {number} [options.from = 1] start opacity\n * @param {number}[options.to = 0] end opacity\n * @param {number} options.duration animation's duration\n * @example\n// import {fadeOut} from \"scenejs\";\n// fadeOut({duration: 2});\nScene.fadeOut({duration: 2});\n// Same\nnew SceneItem({\n    \"0%\": {\n        opacity: 1,\n    },\n    \"100%\": {\n        opacity: 0,\n    }\n}, {\n    duration: 2,\n});\n */\n\nfunction fadeOut(_a) {\n  var _b = _a.from,\n      from = _b === void 0 ? 1 : _b,\n      _c = _a.to,\n      to = _c === void 0 ? 0 : _c;\n  return set(\"opacity\", [from, to], arguments[0]);\n}\n/**\n * Make a blinking effect.\n * @memberof presets\n * @param {AnimatorState} options\n * @param {number} [options.from = 0] start opacity\n * @param {number}[options.to = 1] end opacity\n * @param {number} options.duration animation's duration\n * @example\n// import {blink} from \"scenejs\";\n// blink({duration: 2});\nScene.blink({duration: 2});\n// Same\nnew SceneItem({\n    \"0%\": {\n        opacity: 0,\n    },\n    \"50%\": {\n        opacity: 1,\n    },\n    \"100%\": {\n        opacity: 0,\n    }\n}, {\n    duration: 2,\n});\n */\n\nfunction blink(_a) {\n  var _b = _a.from,\n      from = _b === void 0 ? 0 : _b,\n      _c = _a.to,\n      to = _c === void 0 ? 1 : _c;\n  return set(\"opacity\", [from, to, from], arguments[0]);\n}\n\nexport default Scene;\nexport { SceneItem, Frame, Animator, OPTIONS, EVENTS, FIXED, ROLES, setRole, setAlias, bezier, steps, STEP_START, STEP_END, LINEAR, EASE, EASE_IN, EASE_OUT, EASE_IN_OUT, animate, animateItem, zoomIn, zoomOut, wipeIn, wipeOut, transition, fadeIn, fadeOut, blink };\n//# sourceMappingURL=scene.esm.js.map\n","export const KEYFRAMES_RULE = CSSRule.KEYFRAMES_RULE || (CSSRule as any).WEBKIT_KEYFRAMES_RULE;\nexport const KEYFRAME_RULE = CSSRule.KEYFRAME_RULE || (CSSRule as any).WEBKIT_KEYFRAME_RULE;\n","import { toArray, IObject, isObject, splitComma } from \"@daybrush/utils\";\nimport { Frame } from \"scenejs\";\nimport { KEYFRAMES_RULE, KEYFRAME_RULE } from \"./consts\";\n/**\n * Make the CSS Keyframes the keyframes object.\n * @namespace Keyframer\n */\n\n/**\n* Make the CSS Keyframes the keyframes deep object.\n * @memberof Keyframer\n * @param - The name of the keyframes(`CSSKeyframes​Rule`) in the stylesheet(`CSSStyleSheet`).\n * @returns the keyframes deep object\n * @example\n// @keyframes keyframes {\n//     0% {\n//         opacity: 1;\n//         transform: translate(0px, 0px) rotate(0deg);\n//     }\n//     50% {\n//         opacity: 0;\n//         transform: translate(50px, 0px) rotate(0deg);\n//     }\n//     100% {\n//         opacity: 1;\n//         transform: translate(100px, 0px) rotate(50deg);\n//     }\n// }\n\nimport { getKeyframesObject } from \"keyframer\";\n\nconst obj = getKeyframesObject(\"keyframes\");\n// {\n//     \"0%\": {\n//         opacity: 1,\n//         transform: { translate: \"0px,0px\", rotate: \"0deg\" },\n//     }\n//     \"50%\": {\n//         opacity: 0,\n//         transform: { translate: \"50px,0px\", rotate: \"0deg\" },\n//     },\n//     \"100%\": {\n//         opacity: 1,\n//         transform: { translate: \"100px,0px\", rotate: \"50deg\" },\n//     },\n// }\n */\nexport function getKeyframesObject(name: string | IObject<string>): IObject<any> {\n    const keyframes = isObject(name) ? name : getKeyframes(name);\n    const keyframesObject: IObject<any> = {};\n\n    for (const time in keyframes) {\n        keyframesObject[time] = new Frame(keyframes[time]).get();\n    }\n    return keyframesObject;\n}\n\n/**\n * Make the CSS Keyframes the keyframes object.\n * @memberof Keyframer\n * @param - The name of the keyframes(`CSSKeyframes​Rule`) in the stylesheet(`CSSStyleSheet`).\n * @returns the keyframes object\n * @example\n// @keyframes keyframes {\n//     0% {\n//         opacity: 1;\n//         transform: translate(0px, 0px) rotate(0deg);\n//     }\n//     50% {\n//         opacity: 0;\n//         transform: translate(50px, 0px) rotate(0deg);\n//     }\n//     100% {\n//         opacity: 1;\n//         transform: translate(100px, 0px) rotate(50deg);\n//     }\n// }\n\nimport { getKeyframes } from \"keyframer\";\n\n// {\n//     \"0%\": \"opacity: 1; transform: translate(0px, 0px) rotate(0deg)\",\n//     \"50%\": \"opacity: 0; transform: translate(50px, 0px) rotate(0deg)\",\n//     \"100%\": \"opacity: 1; transform: translate(100px, 0px) rotate(50deg)\",\n// }\nconst obj = getKeyframes(\"keyframes\");\n */\nexport function getKeyframes(name: string): IObject<string> {\n    const styleSheets = toArray(document.styleSheets) as CSSStyleSheet[];\n\n    const sheets = styleSheets.filter(sheet => {\n        try {\n            const length = sheet.cssRules.length;\n\n            return length > 0;\n        } catch (e) {\n            return false;\n        }\n    });\n    const sheetsLength = sheets.length;\n\n    for (let i = 0; i < sheetsLength; ++i) {\n        const sheet = sheets[i];\n        const keyframesRules = toArray(sheet.cssRules) as CSSKeyframesRule[];\n        const keyframesRule = keyframesRules.filter(rule => {\n            return rule.name === name && rule.type === KEYFRAMES_RULE;\n        })[0];\n\n        if (keyframesRule) {\n            const keyframeRules = toArray(keyframesRule.cssRules) as CSSKeyframeRule[];\n            const obj: IObject<string> = {};\n\n            keyframeRules.forEach(rule => {\n                if (rule.type === KEYFRAME_RULE) {\n                    const keyText = rule.keyText;\n                    const cssText = rule.style.cssText;\n\n                    splitComma(keyText).forEach(time => {\n                        obj[time] = cssText;\n                    });\n                }\n            });\n            return obj;\n        }\n    }\n    return {};\n}\n"],"names":["getCrossBrowserProperty","property","doc","styles","body","documentElement","style","length","prefixes","UNDEFINED","i","name","RGB","RGBA","HSL","HSLA","COLOR_MODELS","FUNCTION","PROPERTY","ARRAY","OBJECT","STRING","NUMBER","document","TRANSFORM","FILTER","ANIMATION","isObject","value","isArray","Array","isString","splitComma","text","matches","match","map","str","trim","splitBracket","exec","prefix","suffix","toArray","slice","call","hexToRGBA","hex","h","replace","cutHex","r","parseInt","substring","g","b","a","isNaN","stringToRGBA","color","charAt","join","toFullHex","indexOf","_a","arr","colorArr","parseFloat","hsl","s","l","Math","floor","abs","rgb","c","x","m","round","hslToRGBA","TIMING_FUNCTION","ROLES","transform","filter","attribute","ALIAS","easing","FIXED","contents","PropertyObject","options","model","type","separator","this","setOptions","split","__proto","prototype","newOptions","size","get","index","set","clone","v","toValue","forEach","func","isPropertyObject","getType","getValueByNames","names","properties","isInProperties","roles","args","isCheckTrue","role","isRole","arrayToColorObject","arrayToPropertyObject","toPropertyObject","values","splitSpace","afterModel","obj","stringToBracketObject","result","stringToColorObject","toInnerProperties","arrObj","push","target","merge","to","from","getValue","getPropertyName","Frame","_i","arguments","raw","apply","remove","params","self","_set","concat","toObject","object","isFixed","splitStyle","stylesLength","has","isUndefined","frame","frameProperties","toCSSObject","cssObject","toCSS","cssArray","KEYFRAMES_RULE","CSSRule","WEBKIT_KEYFRAMES_RULE","KEYFRAME_RULE","WEBKIT_KEYFRAME_RULE","getKeyframes","sheets","styleSheets","sheet","cssRules","e","sheetsLength","keyframesRule","rule","keyframeRules","obj_1","keyText","cssText_1","cssText","time","keyframes","keyframesObject"],"mappings":";;;;;;;;sMA+KA,SAFIA,EAEMC,OACHC,QACI,OAGLC,GAAUD,EAAIE,MAAQF,EAAIG,iBAAiBC,MAC3CC,EAASC,EAASD,iBAEXJ,EAAOF,IAAcQ,SACvBR,MAGJ,IAAIS,EAAI,EAAGA,EAAIH,IAAUG,EAAG,KAC3BC,EAAO,IAAMH,EAASE,GAAK,IAAMT,YAE1BE,EAAOQ,IAAUF,SACnBE,QAIJ,GA9KT,IAAIC,EAAM,MAUNC,EAAO,OAUPC,EAAM,MAUNC,EAAO,OAUPC,EAAe,CAACJ,EAAKC,EAAMC,EAAKC,GAUhCE,EAAW,WAUXC,EAAW,WAUXC,EAAQ,QAURC,EAAS,SAUTC,EAAS,SAUTC,EAAS,SAUTb,EAAY,YAuBZP,SAAaqB,UAAad,GAAac,SACvCf,EAAW,CAAC,SAAU,KAAM,MAAO,KAmDnCgB,EAEJxB,EAAwB,aAUpByB,EAEJzB,EAAwB,UAUpB0B,EAEJ1B,EAAwB,aAkDxB,SAAS2B,EAASC,UACTA,UAAgBA,IAAUR,EAgBnC,SAASS,EAAQD,UACRE,MAAMD,QAAQD,GAgBvB,SAASG,EAASH,iBACFA,IAAUP,EAqD1B,SAASW,EAAWC,OAGdC,EAAUD,EAAKE,MAAM,gFAClBD,EAAUA,EAAQE,IAAI,SAAUC,UAC9BA,EAAIC,SACR,GAgBP,SAASC,EAAaN,OAChBC,EAAU,iCAAiCM,KAAKP,UAE/CC,GAAWA,EAAQ3B,OAAS,EACxB,GAEA,CACLkC,OAAQP,EAAQ,GAChBN,MAAOM,EAAQ,GACfQ,OAAQR,EAAQ,IA4FtB,SAASS,EAAQf,SACR,GAAGgB,MAAMC,KAAKjB,GA4EvB,SAASkB,EAAUC,OACbC,EAlBN,SAAgBD,UACPA,EAAIE,QAAQ,IAAK,IAiBhBC,CAAOH,GACXI,EAAIC,SAASJ,EAAEK,UAAU,EAAG,GAAI,IAChCC,EAAIF,SAASJ,EAAEK,UAAU,EAAG,GAAI,IAChCE,EAAIH,SAASJ,EAAEK,UAAU,EAAG,GAAI,IAChCG,EAAIJ,SAASJ,EAAEK,UAAU,EAAG,GAAI,IAAM,WAEtCI,MAAMD,KACRA,EAAI,GAGC,CAACL,EAAGG,EAAGC,EAAGC,GA+EnB,SAASE,EAAaC,MACI,MAApBA,EAAMC,OAAO,UACM,IAAjBD,EAAMpD,QAAiC,IAAjBoD,EAAMpD,OACvBuC,EApEb,SAAmBE,OACbG,EAAIH,EAAEY,OAAO,GACbN,EAAIN,EAAEY,OAAO,GACbL,EAAIP,EAAEY,OAAO,GACbJ,EAAIR,EAAEY,OAAO,SACP,CAAC,IAAKT,EAAGA,EAAGG,EAAGA,EAAGC,EAAGA,EAAGC,EAAGA,GAC1BK,KAAK,IA8DKC,CAAUH,IAEpBb,EAAUa,GAEd,IAA4B,IAAxBA,EAAMI,QAAQ,KAAa,KAEhCC,EAAKzB,EAAaoB,GAClBlB,EAASuB,EAAGvB,OACZb,EAAQoC,EAAGpC,UAEVa,IAAWb,aAIZqC,EAAMjC,EAAWJ,GACjBsC,EAAW,GACX3D,EAAS0D,EAAI1D,cAETkC,QACD7B,OACAC,MACE,IAAIH,EAAI,EAAGA,EAAIH,IAAUG,EAC5BwD,EAASxD,GAAKyD,WAAWF,EAAIvD,WAGxBwD,OAEJpD,OACAC,MACML,EAAI,EAAGA,EAAIH,IAAUG,GACC,IAAzBuD,EAAIvD,GAAGqD,QAAQ,KACjBG,EAASxD,GAAKyD,WAAWF,EAAIvD,IAAM,IAEnCwD,EAASxD,GAAKyD,WAAWF,EAAIvD,WAjFzC,SAAmB0D,OACbpB,EAAIoB,EAAI,GACRC,EAAID,EAAI,GACRE,EAAIF,EAAI,GAERpB,EAAI,IACNA,GAA6C,IAAxCuB,KAAKC,OAAOD,KAAKE,IAAIzB,GAAK,KAAO,MAGxCA,GAAK,QAID0B,EAHAC,GAAK,EAAIJ,KAAKE,IAAI,EAAIH,EAAI,IAAMD,EAChCO,EAAID,GAAK,EAAIJ,KAAKE,IAAIzB,EAAI,GAAK,EAAI,IACnC6B,EAAIP,EAAIK,EAAI,SAGZ3B,EAAI,GACN0B,EAAM,CAACC,EAAGC,EAAG,GACJ5B,EAAI,IACb0B,EAAM,CAACE,EAAGD,EAAG,GACJ3B,EAAI,IACb0B,EAAM,CAAC,EAAGC,EAAGC,GACJ5B,EAAI,IACb0B,EAAM,CAAC,EAAGE,EAAGD,GACJ3B,EAAI,IACb0B,EAAM,CAACE,EAAG,EAAGD,GACJ3B,EAAI,MACb0B,EAAM,CAACC,EAAG,EAAGC,IAGF,CAACL,KAAKO,MAAqB,KAAdJ,EAAI,GAAKG,IAAWN,KAAKO,MAAqB,KAAdJ,EAAI,GAAKG,IAAWN,KAAKO,MAAqB,KAAdJ,EAAI,GAAKG,IAAwB,EAAbT,EAAI7D,OAAa6D,EAAI,GAAK,GAyD3HW,CAAUb,KCxczB,IA0EIF,EA1EAgB,EAAkB,4BAClBC,EAAQ,CACVC,UAAW,GACXC,OAAQ,GACRC,UAAW,IAETC,EAAQ,CACVC,OAAQ,CAACN,IAEPO,IAASvB,EAAK,IAAOgB,IAAmB,EAAMhB,EAAGwB,UAAW,EAAMxB,GAgPlEyB,EAEJ,oBAWWA,EAAe7D,EAAO8D,QACxBjD,OAAS,QACTC,OAAS,QACTiD,MAAQ,QACRC,KAAO,QACPC,UAAY,IACjBH,GAAWI,KAAKC,WAAWL,QACtB9D,MAAQG,EAASH,GAASA,EAAMoE,MAAMF,KAAKD,WAAajE,MAG3DqE,EAAUR,EAAeS,iBAE7BD,EAAQF,WAAa,SAAUI,OACxB,IAAIxF,KAAQwF,OACVxF,GAAQwF,EAAWxF,UAGnBmF,MAWTG,EAAQG,KAAO,kBACNN,KAAKlE,MAAMrB,QAapB0F,EAAQI,IAAM,SAAUC,UACfR,KAAKlE,MAAM0E,IAepBL,EAAQM,IAAM,SAAUD,EAAO1E,eACxBA,MAAM0E,GAAS1E,EACbkE,MAWTG,EAAQO,MAAQ,eACVxC,EAAK8B,KACLD,EAAY7B,EAAG6B,UACfpD,EAASuB,EAAGvB,OACZC,EAASsB,EAAGtB,OACZiD,EAAQ3B,EAAG2B,MACXC,EAAO5B,EAAG4B,YAKP,IAAIH,EAHDK,KAAKlE,MAAMQ,IAAI,SAAUqE,UAC1BA,aAAahB,EAAiBgB,EAAED,QAAUC,IAEpB,CAC7BZ,UAAWA,EACXpD,OAAQA,EACRC,OAAQA,EACRiD,MAAOA,EACPC,KAAMA,KAkBVK,EAAQS,QAAU,kBACTZ,KAAKrD,OAASqD,KAAKjC,OAASiC,KAAKpD,QAgB1CuD,EAAQpC,KAAO,kBACNiC,KAAKlE,MAAMQ,IAAI,SAAUqE,UACvBA,aAAahB,EAAiBgB,EAAEC,UAAYD,IAClD5C,KAAKiC,KAAKD,YAuBfI,EAAQU,QAAU,SAAUC,eACrBhF,MAAM+E,QAAQC,GACZd,MAGFL,EApKT,GAuKA,SAASoB,EAAiBjF,UACjBA,aAAiB6D,EAuB1B,SAASqB,EAAQlF,OACXgE,SAAchE,KAEdgE,IAASxE,EAAQ,IACfS,EAAQD,UACHT,EACF,GAAI0F,EAAiBjF,UACnBV,OAEJ,GAAI0E,IAASvE,GAAUuE,IAAStE,QAC9B,eAGFsE,EAKT,SAASmB,EAAgBC,EAAOC,EAAY1G,QAC3B,IAAXA,IACFA,EAASyG,EAAMzG,gBAGbqB,EAAQqF,EAEHvG,EAAI,EAAGA,EAAIH,IAAUG,EAAG,KAC1BiB,EAASC,UAIdA,EAAQA,EAAMoF,EAAMtG,WAGfkB,EAET,SAASsF,EAAeC,EAAOC,EAAMC,OAC/B9G,EAAS6G,EAAK7G,OACd+G,EAAOH,KAEI,IAAX5G,SACK,MAGJ,IAAIG,EAAI,EAAGA,EAAIH,IAAUG,EAAG,KAClB,IAAT4G,SACK,OAGTA,EAAOA,EAAKF,EAAK1G,OAEH2G,IAAwB,IAATC,SACpB,SAIJ,EAET,SAASC,EAAOH,EAAMC,UACbH,EAAejC,EAAOmC,EAAMC,GAyKrC,SAASG,EAAmBvD,OACtB0B,EAAQ9E,SAEO,IAAfoD,EAAI1D,SACN0D,EAAI,GAAK,GAGJ,IAAIwB,EAAexB,EAAK,CAC7B0B,MAAOA,EACPE,UAAW,IACXD,KAAM,QACNnD,OAAQkD,EAAQ,IAChBjD,OAAQ,MAkDZ,SAAS+E,EAAsBxD,EAAK4B,UAC3B,IAAIJ,EAAexB,EAAK,CAC7B2B,KAAM,QACNC,UAAWA,IAmBf,SAAS6B,EAAiB9F,OACnBG,EAASH,UACRC,EAAQD,GACH6F,EAAsB7F,EAAO,KAG/BA,MAGL+F,EAAS3F,EAAWJ,UAEJ,EAAhB+F,EAAOpH,OACFkH,EAAsBE,EAAOvF,IAAI,SAAUqE,UACzCiB,EAAiBjB,KACtB,KAKc,GAFpBkB,EDxpBF,SAAoB1F,UAEJA,EAAKE,MAAM,8EACP,GCqpBTyF,CAAWhG,IAETrB,OACFkH,EAAsBE,EAAOvF,IAAI,SAAUqE,UACzCiB,EAAiBjB,KACtB,MAGNkB,EAAS,0BAA0BnF,KAAKZ,KAE1B+F,EAAO,KAAOA,EAAO,GAE1B,IAAIlC,EAAe,CAACiC,EAAiBC,EAAO,KAAM,CACvDlF,OAAQkF,EAAO,GACfjF,OAAQiF,EAAO,MAEgB,IAAxB/F,EAAMmC,QAAQ,KA3F3B,SAA+B9B,OAEzB+B,EAAKzB,EAAaN,GAClB0D,EAAQ3B,EAAGvB,OACXb,EAAQoC,EAAGpC,MACXiG,EAAa7D,EAAGtB,eAEC,IAAVd,SACFK,MAG4B,IAAjCjB,EAAa+C,QAAQ4B,UAChB6B,EAAmB9D,EAAazB,QAIrC6F,EAAMJ,EAAiB9F,GACvBqC,EAAM,CAACrC,GACPiE,EAAY,IACZpD,EAASkD,EAAQ,IACjBjD,EAAS,IAAMmF,SAEfC,aAAerC,IACjBI,EAAYiC,EAAIjC,UAChB5B,EAAM6D,EAAIlG,MACVa,GAAUqF,EAAIrF,OACdC,EAASoF,EAAIpF,OAASA,GAGjB,IAAI+C,EAAexB,EAAK,CAC7B4B,UAAWA,EACXF,MAAOA,EACPlD,OAAQA,EACRC,OAAQA,IA4DDqF,CAAsBnG,GACA,MAApBA,EAAMgC,OAAO,GAxC1B,SAA6BhC,OACvBoG,EAAStE,EAAa9B,UACnBoG,EAASR,EAAmBQ,GAAUpG,EAuCpCqG,CAAoBrG,GAGtBA,EAkjBT,SAASsG,EAAkBJ,OACpBA,QACI,OAGLK,EAAS,OAER,IAAIxH,KAAQmH,EACfK,EAAOC,KAAKzH,EAAKsC,QAAQ,MAAO,IAAM,IAAM6E,EAAInH,GAAQ,YAGnDwH,EAAOtE,KAAK,KAKrB,SAAS2C,EAAM6B,EAAQ3B,eACL,IAAZA,IACFA,GAAU,GAGL4B,EAAM,GAAID,EAAQ3B,GAG3B,SAAS4B,EAAMC,EAAIC,EAAM9B,OAKlB,IAAI/F,UAJO,IAAZ+F,IACFA,GAAU,GAGK8B,EAAM,KACjB5G,EAAQ4G,EAAK7H,GACbiF,EAAOkB,EAAQlF,GAEfgE,IAAS1E,EACXqH,EAAG5H,GAAQ+F,EAAU9E,EAAM8E,UAAY9E,EAAM4E,QACpCZ,IAAS3E,EAClBsH,EAAG5H,GAAQ+F,EAAU+B,EAAS,CAAC9H,GAAOiB,GAASA,EACtCgE,IAASzE,EAClBoH,EAAG5H,GAAQiB,EAAMgB,QACRgD,IAASxE,EACdO,EAAS4G,EAAG5H,MAAWkG,EAAiB0B,EAAG5H,IAC7C2H,EAAMC,EAAG5H,GAAOiB,EAAO8E,GAEvB6B,EAAG5H,GAAQ6F,EAAM5E,EAAO8E,GAG1B6B,EAAG5H,GAAQ6H,EAAK7H,UAIb4H,EAKT,SAASG,EAAgBtB,UAChBA,EAAK,KAAM/B,EAAQA,EAAM+B,EAAK,IAAMA,EAG7C,SAASqB,EAASzB,EAAOpF,OACnBgE,EAAOkB,EAAQlF,MAEfgE,IAAS1E,SACJU,EAAM8E,UACR,GAAId,IAAS3E,MACd+F,EAAM,KAAOhC,SACRyD,EAASzB,EAAOpF,UAEpB,GAAIgE,IAASxE,SACXoF,EAAM5E,GAAO,UAGfA,EAOT,IAAI+G,EAEJ,oBAYWA,EAAM1B,QACM,IAAfA,IACFA,EAAa,SAGVA,WAAa,QACbV,IAAIU,OAWPhB,EAAU0C,EAAMzC,iBAEpBD,EAAQI,IAAM,mBACRe,EAAO,GAEFwB,EAAK,EAAGA,EAAKC,UAAUtI,OAAQqI,IACtCxB,EAAKwB,GAAMC,UAAUD,OAGnBhH,EAAQkE,KAAKgD,IAAIC,MAAMjD,KAAMsB,UAC1BqB,EAASC,EAAgBtB,GAAOxF,IAGzCqE,EAAQ6C,IAAM,mBACR1B,EAAO,GAEFwB,EAAK,EAAGA,EAAKC,UAAUtI,OAAQqI,IACtCxB,EAAKwB,GAAMC,UAAUD,UAGhB7B,EAAgB2B,EAAgBtB,GAAOtB,KAAKmB,aAWrDhB,EAAQ+C,OAAS,mBACX5B,EAAO,GAEFwB,EAAK,EAAGA,EAAKC,UAAUtI,OAAQqI,IACtCxB,EAAKwB,GAAMC,UAAUD,OAGnBK,EAASP,EAAgBtB,GACzB7G,EAAS0I,EAAO1I,WAEfA,SACIuF,SAGLlE,EAAQmF,EAAgBkC,EAAQnD,KAAKmB,WAAY1G,EAAS,UAE1DoB,EAASC,WACJA,EAAMqH,EAAO1I,EAAS,IAGxBuF,MA6BTG,EAAQM,IAAM,mBACRa,EAAO,GAEFwB,EAAK,EAAGA,EAAKC,UAAUtI,OAAQqI,IACtCxB,EAAKwB,GAAMC,UAAUD,OAGnBM,EAAOpD,KACPvF,EAAS6G,EAAK7G,OACd0I,EAAS7B,EAAKxE,MAAM,GAAI,GACxBhB,EAAQwF,EAAK7G,EAAS,MAEtB0I,EAAO,KAAM5D,EACf6D,EAAKC,KAAK9D,EAAM4D,EAAO,IAAKrH,QACvB,GAAe,IAAXrB,GAAgBsB,EAAQoH,EAAO,IACxCC,EAAKC,KAAKF,EAAO,GAAIrH,QAChB,GAAIC,EAAQD,GACjBsH,EAAKC,KAAKF,EAAQrH,QACb,GAAIiF,EAAiBjF,GACtB2F,EAAO0B,GACTC,EAAK3C,IAAIwC,MAAMG,EAAMD,EAAOG,OAAO,CAlwB3C,SAASC,EAASC,EAAQtB,QACT,IAAXA,IACFA,EAAS,QAGPrC,EAAQ2D,EAAO3D,SAEfA,EAAO,CACT2D,EAAOvD,WAAW,CAChBJ,MAAO,GACPjD,OAAQ,GACRD,OAAQ,SAENb,EAAwB,EAAhB0H,EAAOlD,OAAakD,EAASA,EAAOjD,IAAI,GACpD2B,EAAOrC,GAAS/D,OAEhB0H,EAAO3C,QAAQ,SAAUmB,GACvBuB,EAASvB,EAAKE,YAIXA,EA6uBmCqB,CAASzH,MAE7CsH,EAAKC,KAAKF,EAAQrH,QAEf,GAAID,EAASC,OACb,IAAIjB,KAAQiB,EACfsH,EAAK3C,IAAIwC,MAAMG,EAAMD,EAAOG,OAAO,CAACzI,EAAMiB,EAAMjB,WAE7C,GAAIoB,EAASH,GAAQ,IACtB2F,EAAO0B,GAAQ,GAAO,IAhjChC,SAAiB7B,UACRF,EAAe3B,EAAO6B,GAAM,GAgjCzBmC,CAAQN,KAAY1B,EAAO0B,QACxBE,KAAKF,EAAQrH,OACb,KACDkG,EAAMJ,EAAiB9F,GAEvBD,EAASmG,IACXoB,EAAK3C,IAAIwC,MAAMG,EAAMD,EAAOG,OAAO,CAACtB,YAIjChC,SAEH9B,EAv7BZ,SAAoB3B,WACd4E,EAAa5E,EAAI2D,MAAM,KACvB8B,EAAM,GACNvH,EAAS0G,EAAW1G,OAEfG,EAAI,EAAGA,EAAIH,IAAUG,EAAG,KAC3BwB,EAAU,qBAAqBM,KAAKyE,EAAWvG,KAE9CwB,GAAWA,EAAQ3B,OAAS,IAAM2B,EAAQ,KAC3C3B,EAIJuH,EAAI5F,EAAQ,GAAGI,QAAUoF,EAAiBxF,EAAQ,GAAGI,cAGhD,CACLnC,OAAQ2H,EACRvH,OAAQA,GAq6BKiJ,CAAW5H,GAChBzB,EAAS6D,EAAG7D,OACZsJ,EAAezF,EAAGzD,WAEjB,IAAII,KAAQR,EACf+I,EAAK3C,IAAIwC,MAAMG,EAAMD,EAAOG,OAAO,CAACzI,EAAMR,EAAOQ,SAG/C8I,SACK3D,KAIXoD,EAAKC,KAAKF,EAAQrH,QAElBsH,EAAKC,KAAKF,EAAQrH,UAGbsH,GAUTjD,EAAQyD,IAAM,mBACRtC,EAAO,GAEFwB,EAAK,EAAGA,EAAKC,UAAUtI,OAAQqI,IACtCxB,EAAKwB,GAAMC,UAAUD,OAGnBK,EAASP,EAAgBtB,GACzB7G,EAAS0I,EAAO1I,eAEfA,IDrkDT,SAAqBqB,iBACLA,GAAUnB,ECwkDdkJ,CAAY5C,EAAgBkC,EAAQnD,KAAKmB,WAAY1G,KAU/D0F,EAAQO,MAAQ,kBACF,IAAImC,GACHL,MAAMxC,OAWrBG,EAAQqC,MAAQ,SAAUsB,OACpB3C,EAAanB,KAAKmB,WAClB4C,EAAkBD,EAAM3C,kBAEvB4C,GAILvB,EAAMrB,EAAY4C,GACX/D,MAQTG,EAAQ6D,YAAc,eAChB7C,EAAanB,KAAKO,MAClB0D,EAAY,OAEX,IAAIpJ,KAAQsG,MACXM,EAAO,CAAC5G,IAAO,QAIfiB,EAAQqF,EAAWtG,GAEnBA,IAASqE,EAKb+E,EAAUpJ,GAAQiB,EAJhBmI,EAAU/E,EAAgB/B,QAAQ,YAAavB,KAAeK,EAASH,GAASA,EAAQA,EAAK,aAAkB,cAO/GsD,EAAYgD,EAAkBjB,EAAU,WACxC9B,EAAS+C,EAAkBjB,EAAW9B,eAC1C3D,GAAa0D,IAAc6E,EAAUvI,GAAa0D,GAClDzD,GAAU0D,IAAW4E,EAAUtI,GAAU0D,GAClC4E,GAQT9D,EAAQ+D,MAAQ,eACVD,EAAYjE,KAAKgE,cACjBG,EAAW,OAEV,IAAItJ,KAAQoJ,EACfE,EAAS7B,KAAKzH,EAAO,IAAMoJ,EAAUpJ,GAAQ,YAGxCsJ,EAASpG,KAAK,KAGvBoC,EAAQkD,KAAO,SAAU/B,EAAMxF,WACzBqF,EAAanB,KAAKmB,WAClB1G,EAAS6G,EAAK7G,OAETG,EAAI,EAAGA,EAAIH,EAAS,IAAKG,EAAG,KAC/BC,EAAOyG,EAAK1G,GACdC,KAAQsG,IAAgBA,EAAWtG,GAAQ,IAC7CsG,EAAaA,EAAWtG,GAGrBJ,IAIL0G,EAAWG,EAAK7G,EAAS,IAAMwB,EAASH,GAAS8F,EAAiB9F,GAASA,IAGtE+G,EApST,GCjpDauB,EAAiBC,QAAQD,gBAAmBC,QAAgBC,sBAC5DC,EAAgBF,QAAQE,eAAkBF,QAAgBG,8BCsFvDC,EAAa5J,WAGnB6J,EAFc7H,EAAQpB,SAASkJ,aAEVtF,OAAO,SAAAuF,cAIV,EAFDA,EAAMC,SAASpK,OAGhC,MAAOqK,UACE,KAGTC,EAAeL,EAAOjK,kBAEnBG,OAGCoK,EADiBnI,EADT6H,EAAO9J,GACgBiK,UACAxF,OAAO,SAAA4F,UACjCA,EAAKpK,OAASA,GAAQoK,EAAKnF,OAASsE,IAC5C,MAECY,EAAe,KACTE,EAAgBrI,EAAQmI,EAAcH,UACtCM,EAAuB,UAE7BD,EAAcrE,QAAQ,SAAAoE,MACdA,EAAKnF,OAASyE,EAAe,KACvBa,EAAUH,EAAKG,QACfC,EAAUJ,EAAKzK,MAAM8K,QAE3BpJ,EAAWkJ,GAASvE,QAAQ,SAAA0E,GACxBJ,EAAII,GAAQF,cAIjBF,KArBNvK,EAAI,EAAGA,EAAImK,IAAgBnK,WAA3BA,8CAwBF,kDA9EwBC,OACzB2K,EAAY3J,EAAShB,GAAQA,EAAO4J,EAAa5J,GACjD4K,EAAgC,OAEjC,IAAMF,KAAQC,EACfC,EAAgBF,GAAQ,IAAI1C,EAAM2C,EAAUD,IAAOhF,aAEhDkF"}